local Library = {}

-- Services
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local TextService = game:GetService("TextService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

--[[
CanvasGroup removal shim
This UI previously used CanvasGroup.GroupTransparency for group fades.
We replace CanvasGroup with Frame and emulate group transparency via a NumberValue
named "GroupAlpha" and per-descendant transparency adjustments.
]]
local _groupBase = setmetatable({}, { __mode = "k" }) -- root -> { inst -> {prop->base} }
local _groupAlphaObj = setmetatable({}, { __mode = "k" }) -- root -> NumberValue

local function _gatherProps(inst)
    local props = {}
    if inst:IsA("GuiObject") then
        if inst.BackgroundTransparency ~= nil then props.BackgroundTransparency = inst.BackgroundTransparency end
        if inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox") then
            props.TextTransparency = inst.TextTransparency
            props.TextStrokeTransparency = inst.TextStrokeTransparency
        end
        if inst:IsA("ImageLabel") or inst:IsA("ImageButton") then
            props.ImageTransparency = inst.ImageTransparency
        end
        if inst:IsA("ScrollingFrame") then
            props.ScrollBarImageTransparency = inst.ScrollBarImageTransparency
        end
    elseif inst:IsA("UIStroke") then
        props.Transparency = inst.Transparency
    end
    return props
end

local function _collectGroupBase(root)
    local base = _groupBase[root]
    if not base then
        base = {}
        _groupBase[root] = base
        local function addOne(obj)
            local props = _gatherProps(obj)
            if next(props) ~= nil then
                base[obj] = props
            end
        end
        addOne(root)
        for _, d in ipairs(root:GetDescendants()) do addOne(d) end
        root.DescendantAdded:Connect(function(d)
            local props = _gatherProps(d)
            if next(props) ~= nil then
                base[d] = props
                local alphaObj = _groupAlphaObj[root]
                if alphaObj then
                    local a = alphaObj.Value or 0
                    -- apply current alpha to the newly added descendant
                    for prop, baseVal in pairs(props) do
                        local final = baseVal + (1 - baseVal) * a
                        pcall(function() d[prop] = final end)
                    end
                end
            end
        end)
        root.DescendantRemoving:Connect(function(d)
            base[d] = nil
        end)
    end
    return base
end

local function _applyGroupTransparency(root, alpha)
    local base = _collectGroupBase(root)
    for inst, props in pairs(base) do
        for prop, baseVal in pairs(props) do
            local final = baseVal + (1 - baseVal) * alpha
            pcall(function() inst[prop] = final end)
        end
    end
end

function Library:_EnsureGroupFader(root)
    if not root or not root.IsA or not root:IsA("GuiObject") then return nil end
    local alphaObj = _groupAlphaObj[root]
    if alphaObj and alphaObj.Parent then return alphaObj end
    alphaObj = Instance.new("NumberValue")
    alphaObj.Name = "GroupAlpha"
    alphaObj.Value = 0
    alphaObj.Parent = root
    _groupAlphaObj[root] = alphaObj
    _collectGroupBase(root)
    alphaObj:GetPropertyChangedSignal("Value"):Connect(function()
        _applyGroupTransparency(root, math.clamp(alphaObj.Value or 0, 0, 1))
    end)
    -- apply initial
    _applyGroupTransparency(root, alphaObj.Value)
    return alphaObj
end

function Library:_SetGroupTransparency(root, value)
    local nv = self:_EnsureGroupFader(root)
    if nv then nv.Value = math.clamp(tonumber(value) or 0, 0, 1) end
end

function Library:_TweenGroupTransparency(root, info, target)
    local nv = self:_EnsureGroupFader(root)
    if not nv then return nil end
    return TweenService:Create(nv, info, { Value = math.clamp(tonumber(target) or 0, 0, 1) })
end

-- Configuration
Library.Config = {
	ToggleKey = Enum.KeyCode.K,
	TabPadding = 2,
	-- Smoothing for window drag
	-- Option A: time-based half-life (seconds). Error halves every this many seconds.
	DragHalfLife = 0.06,
	-- Option B (legacy): responsiveness factor in [0..1] (used if no half-life)
	DragSmoothness = 0.2,
}

-- Themes
Library.Themes = {
	Dark = {
		bg = Color3.fromRGB(12, 14, 18),
		panel = Color3.fromRGB(15, 16, 21),
		panelHighlight = Color3.fromRGB(40, 42, 50),
		text = Color3.fromRGB(230, 235, 240),
		textActive = Color3.fromRGB(255, 255, 255),
		textDim = Color3.fromRGB(140, 146, 156),
		separator = Color3.fromRGB(255, 255, 255),
		accent = Color3.fromRGB(50, 130, 250),
		Success = Color3.fromRGB(39, 174, 96),
		Warning = Color3.fromRGB(242, 201, 76),
		Error = Color3.fromRGB(235, 87, 87),
		Info = Color3.fromRGB(50, 130, 250),
	},
}

Library.Theme = Library.Themes.Dark

-- Internal Registries
Library._widgetRegistry = {}
Library._toggleBinds = {} -- KeyCode -> list of { id, set, get, type }

-- Runtime state guards
Library._captureBlockInput = false
Library._suppressCallbacks = false

-- Text helper placed early so Key System sees the local
local function asText(value, default)
    local t = typeof(value)
    if t == "string" then return value end
    if t == "number" or t == "boolean" then return tostring(value) end
    return default or ""
end

-- Compatibility helpers (task/clipboard fallbacks)
local function _hasFunc(f)
    return typeof(f) == "function"
end

local function _waitCompat(seconds)
    if _hasFunc(task and task.wait) then
        return task.wait(seconds)
    end
    if _hasFunc(wait) then
        return wait(seconds)
    end
    -- Last-resort wait loop using Heartbeat
    local rs = game:GetService("RunService")
    if seconds == nil then
        return rs.Heartbeat:Wait()
    end
    local t0 = tick()
    repeat rs.Heartbeat:Wait() until (tick() - t0) >= (seconds or 0)
    return seconds or 0
end

local function _delayCompat(seconds, fn)
    if not _hasFunc(fn) then return end
    if _hasFunc(task and task.delay) then
        return task.delay(seconds, fn)
    end
    if _hasFunc(delay) then
        return delay(seconds, fn)
    end
    -- Fallback: spawn + wait
    if _hasFunc(spawn) then
        spawn(function()
            _waitCompat(seconds)
            pcall(fn)
        end)
    else
        -- final fallback: run immediately
        pcall(fn)
    end
end

local function _copyToClipboard(text)
    if typeof(text) ~= "string" then return false end
    -- Try common executor APIs
    if _hasFunc(setclipboard) then
        local ok = pcall(setclipboard, text)
        if ok then return true end
    end
    if _hasFunc(toclipboard) then
        local ok = pcall(toclipboard, text)
        if ok then return true end
    end
    return false
end

local function _deferCompat(fn)
    if typeof(fn) ~= "function" then return end
    if _hasFunc(task and task.defer) then
        return task.defer(fn)
    end
    if _hasFunc(spawn) then
        return spawn(fn)
    end
    pcall(fn)
end

-- Auto-Save Properties
Library.autoSaveEnabled = false
Library.autoSaveFile = nil
Library.autoSaveData = {}

-- Localization
Library.Locale = "en"
Library.Locales = {
    en = {
        ["GUI.Settings"] = "GUI Settings",
        ["GUI.AutoSave"] = "Auto Save",
        ["GUI.SaveNow"] = "Save Now",
        ["GUI.MenuToggleKey"] = "Menu Toggle Key",
        ["GUI.AccentColor"] = "Accent Color",
        ["GUI.Language"] = "Language",
        ["GUI.LanguageChangedTitle"] = "Language",
        ["Common.Enabled"] = "Enabled",
        ["Common.Disabled"] = "Disabled",
        ["Notify.SettingsSaved"] = "Settings saved.",
        ["Notify.SaveFailed"] = "Failed to save settings.",
        ["Notify.JSONEncodeFailed"] = "JSON encode failed.",
        -- Key system
        ["KeySystem.Title"] = "Verification",
        ["KeySystem.Description"] = "Please enter your key below to gain access.",
        ["KeySystem.Placeholder"] = "Enter your key here...",
        ["KeySystem.GetKey"] = "Get Key",
        ["KeySystem.VerifyKey"] = "Verify Key",
        ["KeySystem.CopySuccess"] = "Discord link copied!",
        ["KeySystem.CopyFallback"] = "Copy failed. Link: ",
        ["KeySystem.Verifying"] = "Verifying...",
        ["KeySystem.Success"] = "Success! Access Granted.",
        ["KeySystem.Error"] = "Invalid Key. Please try again.",
    },
    ru = {
        ["GUI.Settings"] = "Настройки GUI",
        ["GUI.AutoSave"] = "Автосохранение",
        ["GUI.SaveNow"] = "Сохранить сейчас",
        ["GUI.MenuToggleKey"] = "Клавиша меню",
        ["GUI.AccentColor"] = "Цвет акцента",
        ["GUI.Language"] = "Язык",
        ["GUI.LanguageChangedTitle"] = "Язык",
        ["Common.Enabled"] = "Включено",
        ["Common.Disabled"] = "Выключено",
        ["Notify.SettingsSaved"] = "Настройки сохранены.",
        ["Notify.SaveFailed"] = "Не удалось сохранить настройки.",
        ["Notify.JSONEncodeFailed"] = "Ошибка кодирования JSON.",
        -- Key system
        ["KeySystem.Title"] = "Проверка",
        ["KeySystem.Description"] = "Введите ключ ниже, чтобы получить доступ.",
        ["KeySystem.Placeholder"] = "Введите ваш ключ...",
        ["KeySystem.GetKey"] = "Получить ключ",
        ["KeySystem.VerifyKey"] = "Проверить ключ",
        ["KeySystem.CopySuccess"] = "Ссылка Discord скопирована!",
        ["KeySystem.CopyFallback"] = "Не удалось скопировать. Ссылка: ",
        ["KeySystem.Verifying"] = "Проверка...",
        ["KeySystem.Success"] = "Успешно! Доступ предоставлен.",
        ["KeySystem.Error"] = "Неверный ключ. Попробуйте снова.",
    }
}

Library._languageChangedCallbacks = {}
function Library:_T(key, fallback)
    local lang = self.Locale or "en"
    local dict = self.Locales[lang]
    local value = dict and dict[key]
    if typeof(value) == "string" then return value end
    return fallback or key
end

function Library:_onLanguageChanged(cb)
    table.insert(self._languageChangedCallbacks, cb)
end

function Library:SetLanguage(code)
    if typeof(code) ~= "string" then return false end
    local c = string.lower(code)
    if c ~= "en" and c ~= "ru" then return false end
    self.Locale = c
    self:_SaveSetting("ui_language", c)
    for _, cb in ipairs(self._languageChangedCallbacks) do
        pcall(cb, c)
    end
    local name = (c == "ru") and "Русский" or "English"
    self:Notify({ Title = self:_T("GUI.LanguageChangedTitle", "Language"), Text = name, Duration = 2 })
    return true
end

-- Accent management
Library._accentTargets = {}
Library._accentChangedCallbacks = {}
function Library:_RegisterAccent(inst, property)
    if inst and inst[property] ~= nil then
        inst[property] = self.Theme.accent
        table.insert(self._accentTargets, { inst = inst, prop = property })
    end
end
function Library:_OnAccentChanged(cb)
    table.insert(self._accentChangedCallbacks, cb)
end
function Library:SetAccent(color)
    local named = {}
    named.blue   = Color3.fromRGB(50, 130, 250)
    named.red    = Color3.fromRGB(235, 87, 87)
    named.orange = Color3.fromRGB(255, 159, 67)
    named.purple = Color3.fromRGB(155, 89, 182)
    named.pink   = Color3.fromRGB(255, 99, 179)
    named.green  = Color3.fromRGB(39, 174, 96)

    local c = self.Theme.accent
    if typeof(color) == "string" then
        local key = string.lower(color)
        c = named[key] or c
    elseif typeof(color) == "Color3" then
        c = color
    end

    self.Theme.accent = c
    -- persist by name if possible
    local saveName = nil
    for k, v in pairs(named) do if v == c then saveName = k break end end
    self:_SaveSetting("ui_accent_color", saveName or string.format("rgb(%d,%d,%d)", math.floor(c.R*255), math.floor(c.G*255), math.floor(c.B*255)))

    for _, ref in ipairs(self._accentTargets) do
        local ok = pcall(function() ref.inst[ref.prop] = c end)
    end
    for _, cb in ipairs(self._accentChangedCallbacks) do
        pcall(cb, c)
    end
end

local function deepCopy(tbl)
	if typeof(tbl) ~= "table" then
		return tbl
	end
	local result = {}
	for key, value in pairs(tbl) do
		result[key] = deepCopy(value)
	end
	return result
end

local function deepMerge(target, source)
	for key, value in pairs(source) do
		if typeof(value) == "table" and typeof(target[key]) == "table" then
			deepMerge(target[key], value)
		else
			target[key] = value
		end
	end
	return target
end

local DEFAULT_KEY_SYSTEM_THEME = {
	bg = Color3.fromRGB(12, 14, 18),
	panel = Color3.fromRGB(16, 18, 24),
	text = Color3.fromRGB(230, 235, 240),
	textDim = Color3.fromRGB(170, 176, 186),
	accentA = Color3.fromRGB(64, 156, 255),
	btn = Color3.fromRGB(28, 30, 36),
	btnHover = Color3.fromRGB(36, 38, 46),
	success = Color3.fromRGB(40, 167, 69),
	successHover = Color3.fromRGB(60, 187, 89),
	error = Color3.fromRGB(220, 53, 69),
}

local DEFAULT_KEY_SYSTEM_CONFIG = {
	Enabled = false,
	Key = "Eps1llon",
	Title = "Eps1llon Hub | Verification",
	Description = "Please enter your key below to gain access.",
	PlaceholderText = "Enter your key here...",
	DiscordLink = "https://discord.gg/Eps1llon",
	CopySuccessText = "Discord link copied!",
	CopyFallbackText = "Copy failed. Link: discord.gg/Eps1llon",
	VerifyingText = "Verifying...",
	SuccessText = "Success! Access Granted.",
	ErrorText = "Invalid Key. Please try again.",
	GetKeyText = "Get Key",
	VerifyButtonText = "Verify Key",
	SaveFile = "eps_key_system.json",
	SaveIdentifier = "_Eps1llonKeySystemVerified",
	Theme = DEFAULT_KEY_SYSTEM_THEME,
}

Library.KeySystemConfig = deepCopy(DEFAULT_KEY_SYSTEM_CONFIG)
Library._keySystemVerified = false

--[[ Saving and Loading ]]

function Library:InitAutoSave(fileName)
    local HttpService = game:GetService("HttpService")
    self.autoSaveEnabled = true
    self.autoSaveFile = fileName or "ui_autosave.json"
    self.autoSaveData = {}
	if typeof(isfile) == "function" and typeof(readfile) == "function" and isfile(self.autoSaveFile) then
		local ok, data = pcall(readfile, self.autoSaveFile)
		if ok and data and data ~= "" then
			local success, decoded = pcall(HttpService.JSONDecode, HttpService, data)
            if success and typeof(decoded) == "table" then
                self.autoSaveData = decoded
                local savedLang = decoded["ui_language"]
                if typeof(savedLang) == "string" and (savedLang == "en" or savedLang == "ru") then
                    self.Locale = savedLang
                end
                local savedAccent = decoded["ui_accent_color"]
                if savedAccent ~= nil then
                    pcall(function() self:SetAccent(savedAccent) end)
                end
            end
        end
    end
end

function Library:UseSaveModule(opts)
    opts = opts or {}
    -- Backward-compat wrapper. Prefer Library:CreateGUISettingsSection.
    local win = opts.Window
    if not win then
        warn("UseSaveModule: missing Window in options")
        return
    end
    local page = win:CreatePage({ Title = opts.PageTitle or "Save", Icon = opts.Icon })
    self:CreateGUISettingsSection({
        Page = page,
        SectionTitle = opts.SectionTitle or "Save Manager",
        FileName = opts.FileName,
        ToggleKeyTitle = opts.ToggleKeyTitle,
        ToggleKeySaveKey = opts.ToggleKeySaveKey,
    })
end

function Library:_SaveSetting(key, value)
	if not self.autoSaveEnabled or not key then return end
	self.autoSaveData[key] = value
	local HttpService = game:GetService("HttpService")
	local ok, json = pcall(HttpService.JSONEncode, HttpService, self.autoSaveData)
	if ok and typeof(writefile) == "function" then
		pcall(writefile, self.autoSaveFile, json)
	end
end

-- Create a GUI settings section inside an existing page
function Library:CreateGUISettingsSection(opts)
    opts = opts or {}
    local page = opts.Page or opts.page
    if not page or typeof(page) ~= "table" or not page.CreateSection then
        warn("CreateGUISettingsSection: missing or invalid Page")
        return nil
    end

    local section = page:CreateSection({ Title = opts.SectionTitle or self:_T("GUI.Settings", "GUI Settings"), Icon = opts.Icon })

    -- Auto Save toggle
    local autoToggle = section:CreateToggle({
        Title = opts.AutoSaveTitle or self:_T("GUI.AutoSave", "Auto Save"),
        Default = self.autoSaveEnabled,
        SaveKey = opts.AutoSaveSaveKey or "ui_auto_save_enabled",
        Callback = function(v)
            self.autoSaveEnabled = v
            self:Notify({ Title = self:_T("GUI.AutoSave", "Auto Save"), Text = v and self:_T("Common.Enabled", "Enabled") or self:_T("Common.Disabled", "Disabled"), Duration = 3 })
            if v and not self.autoSaveFile then
                self.autoSaveFile = opts.FileName or "ui_settings.json"
            end
        end,
    })

    -- Save Now button
    local saveBtn = section:CreateButton({
        Title = opts.SaveNowTitle or self:_T("GUI.SaveNow", "Save Now"),
        Callback = function()
            if not self.autoSaveEnabled then
                self:Notify({ Title = self:_T("GUI.SaveNow", "Save Now"), Text = self:_T("Common.Disabled", "Disabled"), Duration = 3 })
                return
            end
            local HttpService = game:GetService("HttpService")
            local ok, json = pcall(HttpService.JSONEncode, HttpService, self.autoSaveData)
            if ok and typeof(writefile) == "function" then
                local success = pcall(writefile, self.autoSaveFile, json)
                if success then
                    self:Notify({ Title = self:_T("GUI.SaveNow", "Save Now"), Text = self:_T("Notify.SettingsSaved", "Settings saved."), Duration = 3 })
                else
                    self:Notify({ Title = self:_T("GUI.SaveNow", "Save Now"), Text = self:_T("Notify.SaveFailed", "Failed to save settings."), Duration = 4 })
                end
            else
                self:Notify({ Title = self:_T("GUI.SaveNow", "Save Now"), Text = self:_T("Notify.JSONEncodeFailed", "JSON encode failed."), Duration = 4 })
            end
        end,
    })

    -- Menu toggle keybind
    local keybindObj
    if section.CreateKeybind then
        keybindObj = section:CreateKeybind({
            Title = opts.ToggleKeyTitle or self:_T("GUI.MenuToggleKey", "Menu Toggle Key"),
            Default = self.Config.ToggleKey,
            SaveKey = opts.ToggleKeySaveKey or "ui_toggle_key",
            Callback = function(kc)
                self.Config.ToggleKey = kc
                self:_SaveSetting(opts.ToggleKeySaveKey or "ui_toggle_key", kc.Name)
                self:Notify({ Title = "Keybind", Text = "Toggle key set to " .. kc.Name, Duration = 3 })
            end,
        })
    end

    -- Language dropdown (English / Russian)
    local codeToName = { en = "English", ru = "Русский" }
    local nameToCode = { ["English"] = "en", ["Русский"] = "ru" }
    local savedLang = self:_GetSetting("ui_language", self.Locale or "en")
    if typeof(savedLang) ~= "string" or not codeToName[savedLang] then savedLang = "en" end
    self.Locale = savedLang

    local items = { "English", "Русский" }
    local defaultIndex = 1
    for i, n in ipairs(items) do if n == codeToName[savedLang] then defaultIndex = i break end end

    local langDropdown = section:CreateDropdown({
        Title = self:_T("GUI.Language", "Language"),
        Items = items,
        Default = defaultIndex,
        Callback = function(name)
            local code = nameToCode[name] or "en"
            self:SetLanguage(code)
            -- Update static labels inside this section when language changes
            if autoToggle and autoToggle.Object then
                for _, ch in ipairs(autoToggle.Object:GetChildren()) do
                    if ch:IsA("TextLabel") then ch.Text = self:_T("GUI.AutoSave", "Auto Save") break end
                end
            end
            if saveBtn and saveBtn.Object then
                saveBtn.Object.Text = self:_T("GUI.SaveNow", "Save Now")
            end
            if section and typeof(section) == "table" and keybindObj and keybindObj.Object then
                local holder = keybindObj.Object.Parent
                if holder then
                    for _, ch in ipairs(holder:GetChildren()) do
                        if ch:IsA("TextLabel") then ch.Text = self:_T("GUI.MenuToggleKey", "Menu Toggle Key") break end
                    end
                end
            end
            if langDropdown and langDropdown.Object then
                local holder = langDropdown.Object.Parent
                if holder then
                    for _, ch in ipairs(holder:GetChildren()) do
                        if ch:IsA("TextLabel") then ch.Text = self:_T("GUI.Language", "Language") break end
                    end
                end
            end
        end,
    })

    -- Accent color picker
    local accentItems = { "Blue", "Red", "Orange", "Purple", "Pink", "Green" }
    local accentMap = { Blue = "blue", Red = "red", Orange = "orange", Purple = "purple", Pink = "pink", Green = "green" }
    local savedAccent = self:_GetSetting("ui_accent_color", nil)
    local defaultAccentIndex = 1
    if typeof(savedAccent) == "string" then
        local wanted = nil
        for i, n in ipairs(accentItems) do if string.lower(n) == string.lower(savedAccent) or accentMap[n] == string.lower(savedAccent) then defaultAccentIndex = i break end end
    end
    section:CreateDropdown({
        Title = self:_T("GUI.AccentColor", "Accent Color"),
        Items = accentItems,
        Default = defaultAccentIndex,
        SaveKey = "ui_accent_color",
        Callback = function(name)
            local key = accentMap[name] or name
            self:SetAccent(key)
        end,
    })

    return section
end

function Library:_GetSetting(key, default)
	if not self.autoSaveEnabled or not key then return default end
	local value = self.autoSaveData[key]
	if value == nil then
		return default
	else
		return value
	end
end

local function getSharedEnvironment()
	if typeof(getgenv) == "function" then
		local ok, env = pcall(getgenv)
		if ok and typeof(env) == "table" then
			return env
		end
	end
	return nil
end

local function encodeJSON(data)
	local ok, json = pcall(HttpService.JSONEncode, HttpService, data)
	if ok then
		return json
	end
	return nil
end

local function decodeJSON(data)
	local ok, decoded = pcall(HttpService.JSONDecode, HttpService, data)
	if ok then
		return decoded
	end
	return nil
end

-- KeyCode helpers for saving/restoring keybinds
local function keycodeToString(kc)
    if typeof(kc) == "EnumItem" then
        return kc.Name
    elseif typeof(kc) == "string" then
        return kc
    end
    return "None"
end

local function stringToKeycode(s)
    if typeof(s) == "EnumItem" then return s end
    if typeof(s) == "string" and Enum.KeyCode[s] then
        return Enum.KeyCode[s]
    end
    return nil
end

function Library:SetToggleKey(key)
    local kc = key
    if typeof(key) == "string" then
        kc = stringToKeycode(key)
    end
    if typeof(kc) == "EnumItem" then
        self.Config.ToggleKey = kc
        return true
    end
    return false
end

--[[ Key System ]]

function Library:ConfigureKeySystem(options)
	if options == nil then
		return deepCopy(self.KeySystemConfig)
	end

	if typeof(options) == "boolean" then
		self.KeySystemConfig.Enabled = options
		return deepCopy(self.KeySystemConfig)
	end

	local config = deepCopy(self.KeySystemConfig)
	local opts = deepCopy(options)
	local themeOverride = opts.Theme
	opts.Theme = nil

	deepMerge(config, opts)

	if options.key ~= nil and options.Key == nil then
		config.Key = options.key
	end

	if options.enabled ~= nil and options.Enabled == nil then
		config.Enabled = options.enabled
	elseif options.Enabled ~= nil then
		config.Enabled = options.Enabled
	elseif options.Key ~= nil or options.key ~= nil or themeOverride ~= nil then
		config.Enabled = true
	end

	if themeOverride ~= nil then
		if typeof(themeOverride) == "table" then
			local theme = deepCopy(DEFAULT_KEY_SYSTEM_THEME)
			deepMerge(theme, themeOverride)
			config.Theme = theme
		else
			config.Theme = deepCopy(DEFAULT_KEY_SYSTEM_THEME)
		end
	end

	self.KeySystemConfig = config

	return deepCopy(self.KeySystemConfig)
end

function Library:_IsKeySystemVerified()
	if self._keySystemVerified then
		return true
	end

	local config = self.KeySystemConfig
	local sharedEnv = getSharedEnvironment()

	if sharedEnv then
		local cached = sharedEnv[config.SaveIdentifier]
		if typeof(cached) == "table" and cached.verified and cached.key == config.Key then
			self._keySystemVerified = true
			return true
		end
	end

	if typeof(isfile) == "function" and typeof(readfile) == "function" and isfile(config.SaveFile) then
		local ok, contents = pcall(readfile, config.SaveFile)
		if ok and contents and contents ~= "" then
			local decoded = decodeJSON(contents)
			if typeof(decoded) == "table" and decoded.verified and decoded.key == config.Key then
				self._keySystemVerified = true
				if sharedEnv then
					sharedEnv[config.SaveIdentifier] = decoded
				end
				return true
			end
		end
	end

	return false
end

function Library:_PersistKeySystemVerification()
	local config = self.KeySystemConfig
	local payload = {
		verified = true,
		key = config.Key,
		timestamp = os.time(),
	}

	local json = encodeJSON(payload)
	if json and typeof(writefile) == "function" then
		pcall(writefile, config.SaveFile, json)
	end

	local sharedEnv = getSharedEnvironment()
	if sharedEnv then
		sharedEnv[config.SaveIdentifier] = payload
	end

	self._keySystemVerified = true
end

function Library:_ShowKeySystemPrompt()
	local config = self.KeySystemConfig
	local theme = deepCopy(DEFAULT_KEY_SYSTEM_THEME)
	if typeof(config.Theme) == "table" then
		deepMerge(theme, config.Theme)
	end

	if PlayerGui:FindFirstChild("KeySystemGUI") then
		PlayerGui.KeySystemGUI:Destroy()
	end

    local keyGui = Instance.new("ScreenGui")
	keyGui.Name = "KeySystemGUI"
	keyGui.ResetOnSpawn = false
	keyGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	keyGui.Parent = PlayerGui

	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 360, 0, 250)
	mainFrame.Position = UDim2.new(0.5, -180, 0.5, -125)
	mainFrame.BackgroundColor3 = theme.panel
	mainFrame.BorderSizePixel = 0
	mainFrame.ClipsDescendants = true
	mainFrame.ZIndex = 2
	mainFrame.Active = true
	mainFrame.Draggable = true
	mainFrame.Parent = keyGui

	Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)

	local stroke = Instance.new("UIStroke", mainFrame)
	stroke.Color = theme.accentA
	stroke.Transparency = 0.7
	stroke.Thickness = 1.5
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

    local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0, 30)
	titleLabel.Position = UDim2.new(0, 0, 0, 15)
	titleLabel.BackgroundTransparency = 1
    titleLabel.Text = asText(config.Title, self:_T("KeySystem.Title", "Verification"))
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextColor3 = theme.text
	titleLabel.TextSize = 18
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.ZIndex = 3
	titleLabel.Parent = mainFrame

    local descriptionLabel = Instance.new("TextLabel")
	descriptionLabel.Name = "Description"
	descriptionLabel.Size = UDim2.new(1, -40, 0, 30)
	descriptionLabel.Position = UDim2.new(0, 20, 0, 40)
	descriptionLabel.BackgroundTransparency = 1
    descriptionLabel.Text = asText(config.Description, self:_T("KeySystem.Description", "Please enter your key below to gain access."))
	descriptionLabel.Font = Enum.Font.Gotham
	descriptionLabel.TextColor3 = theme.textDim
	descriptionLabel.TextSize = 13
	descriptionLabel.TextWrapped = true
	descriptionLabel.TextXAlignment = Enum.TextXAlignment.Center
	descriptionLabel.TextYAlignment = Enum.TextYAlignment.Top
	descriptionLabel.ZIndex = 3
	descriptionLabel.Parent = mainFrame

	local feedbackLine = Instance.new("Frame")
	feedbackLine.Name = "FeedbackLine"
	feedbackLine.Size = UDim2.new(0, 0, 0, 3)
	feedbackLine.Position = UDim2.new(0, 20, 0, 75)
	feedbackLine.BackgroundColor3 = theme.accentA
	feedbackLine.BorderSizePixel = 0
	feedbackLine.ZIndex = 5
	feedbackLine.Parent = mainFrame
	Instance.new("UICorner", feedbackLine).CornerRadius = UDim.new(1, 0)

	local keyInput = Instance.new("TextBox")
	keyInput.Name = "KeyInput"
	keyInput.Size = UDim2.new(1, -40, 0, 38)
	keyInput.Position = UDim2.new(0, 20, 0, 80)
	keyInput.BackgroundColor3 = theme.bg
	keyInput.Text = ""
    keyInput.PlaceholderText = asText(config.PlaceholderText, self:_T("KeySystem.Placeholder", "Enter your key here..."))
	keyInput.PlaceholderColor3 = theme.textDim
	keyInput.Font = Enum.Font.Gotham
	keyInput.TextColor3 = theme.text
	keyInput.TextSize = 14
	keyInput.ClearTextOnFocus = false
	keyInput.TextXAlignment = Enum.TextXAlignment.Center
	keyInput.ZIndex = 4
	keyInput.Parent = mainFrame

	Instance.new("UICorner", keyInput).CornerRadius = UDim.new(0, 8)

	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "StatusLabel"
	statusLabel.Size = UDim2.new(1, 0, 0, 20)
	statusLabel.Position = UDim2.new(0, 0, 0, 123)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = ""
	statusLabel.Font = Enum.Font.GothamBold
	statusLabel.TextColor3 = theme.textDim
	statusLabel.TextSize = 13
	statusLabel.TextXAlignment = Enum.TextXAlignment.Center
	statusLabel.ZIndex = 3
	statusLabel.Parent = mainFrame

	local getKeyButton = Instance.new("TextButton")
	getKeyButton.Name = "GetKeyButton"
	getKeyButton.Size = UDim2.new(1, -40, 0, 38)
	getKeyButton.Position = UDim2.new(0, 20, 0, 150)
	getKeyButton.BackgroundColor3 = theme.btn
    getKeyButton.Text = asText(config.GetKeyText, self:_T("KeySystem.GetKey", "Get Key"))
	getKeyButton.Font = Enum.Font.GothamBold
	getKeyButton.TextColor3 = theme.text
	getKeyButton.TextSize = 15
	getKeyButton.ZIndex = 4
	getKeyButton.Parent = mainFrame

	Instance.new("UICorner", getKeyButton).CornerRadius = UDim.new(0, 8)

	local verifyButton = Instance.new("TextButton")
	verifyButton.Name = "VerifyButton"
	verifyButton.Size = UDim2.new(1, -40, 0, 38)
	verifyButton.Position = UDim2.new(0, 20, 0, 195)
	verifyButton.BackgroundColor3 = theme.success
    verifyButton.Text = asText(config.VerifyButtonText, self:_T("KeySystem.VerifyKey", "Verify Key"))
	verifyButton.Font = Enum.Font.GothamBold
	verifyButton.TextColor3 = Color3.new(1, 1, 1)
	verifyButton.TextSize = 15
	verifyButton.ZIndex = 4
	verifyButton.Parent = mainFrame

	Instance.new("UICorner", verifyButton).CornerRadius = UDim.new(0, 8)

	local isVerifying = false

	local function recursiveFade(instance, targetTransparency)
		local fadeInfo = TweenInfo.new(0.4)
		if instance:IsA("GuiObject") then
			if pcall(function() return instance.BackgroundTransparency end) then
				TweenService:Create(instance, fadeInfo, { BackgroundTransparency = targetTransparency }):Play()
			end
			if pcall(function() return instance.TextTransparency end) then
				TweenService:Create(instance, fadeInfo, { TextTransparency = targetTransparency }):Play()
			end
			if pcall(function() return instance.ImageTransparency end) then
				TweenService:Create(instance, fadeInfo, { ImageTransparency = targetTransparency }):Play()
			end
		end
		if pcall(function() return instance.Transparency end) and instance:IsA("UIStroke") then
			TweenService:Create(instance, fadeInfo, { Transparency = targetTransparency }):Play()
		end
		for _, child in ipairs(instance:GetChildren()) do
			recursiveFade(child, targetTransparency)
		end
	end

	local function shakeUI()
		local originalPos = mainFrame.Position
		for _ = 1, 5 do
			mainFrame.Position = originalPos + UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
            _waitCompat(0.02)
		end
		mainFrame.Position = originalPos
	end

	local completionEvent = Instance.new("BindableEvent")

    getKeyButton.Activated:Connect(function()
        if config.DiscordLink and _copyToClipboard(config.DiscordLink) then
            statusLabel.Text = asText(config.CopySuccessText, self:_T("KeySystem.CopySuccess", "Discord link copied!"))
            statusLabel.TextColor3 = theme.success
        else
            local fallbackText = asText(config.CopyFallbackText, self:_T("KeySystem.CopyFallback", "Copy failed. Link: "))
            statusLabel.Text = fallbackText .. (config.DiscordLink or "")
            statusLabel.TextColor3 = theme.error
        end
        _delayCompat(2, function()
            if statusLabel then
                statusLabel.Text = ""
            end
        end)
    end)

    verifyButton.Activated:Connect(function()
        if isVerifying then
            return
        end
        isVerifying = true

        statusLabel.Text = asText(config.VerifyingText, self:_T("KeySystem.Verifying", "Verifying..."))
        statusLabel.TextColor3 = theme.textDim

		feedbackLine.Size = UDim2.new(0, 0, 0, 3)
		local lineAnim = TweenService:Create(feedbackLine, TweenInfo.new(0.5, Enum.EasingStyle.Linear), { Size = UDim2.new(1, -40, 0, 3) })
		lineAnim:Play()

        _waitCompat(0.6)

        if keyInput.Text == tostring(config.Key) then
            statusLabel.Text = asText(config.SuccessText, self:_T("KeySystem.Success", "Success! Access Granted."))
            statusLabel.TextColor3 = theme.success

			self:_PersistKeySystemVerification()

			recursiveFade(mainFrame, 1)
			local mainFade = TweenService:Create(mainFrame, TweenInfo.new(0.5), { BackgroundTransparency = 1 })
			mainFade.Completed:Connect(function()
				keyGui:Destroy()
				completionEvent:Fire(true)
				completionEvent:Destroy()
			end)
			mainFade:Play()
        else
            statusLabel.Text = asText(config.ErrorText, self:_T("KeySystem.Error", "Invalid Key. Please try again."))
            statusLabel.TextColor3 = theme.error
            shakeUI()

			TweenService:Create(feedbackLine, TweenInfo.new(0.3), { Size = UDim2.new(0, 0, 0, 3) }):Play()
			isVerifying = false
		end
	end)

    -- Wait for completion robustly, even if :Wait() is unavailable
    local evt = completionEvent.Event
    if _hasFunc(evt and evt.Wait) then
        return evt:Wait()
    end
    local result
    local done = false
    local conn
    conn = evt:Connect(function(v)
        result = v
        done = true
        if conn then conn:Disconnect() end
    end)
    while not done do _waitCompat(0.03) end
    return result
end

function Library:_EnsureKeySystem()
	if not self.KeySystemConfig.Enabled then
		return true
	end

	if self:_IsKeySystemVerified() then
		return true
	end

	return self:_ShowKeySystemPrompt()
end

--[[ Utility Functions ]]

local function toTitleCase(s)
    return (s:gsub("(%a)([%w_']*)", function(first, rest)
        return first:upper() .. rest:lower()
    end))
end

-- asText defined near the top for early use by Key System

-- User-facing translation hook for app content (page/section/titles, etc.).
-- If provided via Library:SetTranslator, it will be called for every label
-- that comes from user opts. Defaults to identity.
function Library:_Translate(text)
    if typeof(text) ~= "string" then return text end
    local cb = rawget(self, "TranslateCallback")
    if typeof(cb) == "function" then
        local ok, out = pcall(cb, text, self.Locale)
        if ok and typeof(out) == "string" and out ~= "" then
            return out
        end
    end
    return text
end

-- Lightweight i18n bindings so UI updates when language changes
function Library:_BindLocaleText(instance, rawText)
    if not instance or typeof(rawText) ~= "string" then return end
    local function apply()
        local newText = self:_Translate(rawText)
        pcall(function() instance.Text = newText end)
    end
    -- Apply now and on language change
    apply()
    self:_onLanguageChanged(function()
        apply()
    end)
end

function Library:_BindLocalePlaceholder(instance, rawText)
    if not instance or typeof(rawText) ~= "string" then return end
    local function apply()
        local newText = self:_Translate(rawText)
        pcall(function() instance.PlaceholderText = newText end)
    end
    apply()
    self:_onLanguageChanged(function()
        apply()
    end)
end

function Library:SetTranslator(fn)
    if typeof(fn) == "function" then
        self.TranslateCallback = fn
        return true
    end
    self.TranslateCallback = nil
    return false
end

-- Auto-detect player locale and apply ru/en when not overridden by a saved preference.
function Library:AutoDetectLanguage(opts)
    opts = opts or {}
    local force = opts.Force or false
    local saved = self.autoSaveEnabled and self.autoSaveData and self.autoSaveData["ui_language"]
    if saved and not force then return saved end
    local code = "en"
    local ok, loc = pcall(function()
        local ls = game:GetService("LocalizationService")
        local players = game:GetService("Players")
        return (ls.RobloxLocaleId ~= "" and ls.RobloxLocaleId)
            or (ls.SystemLocaleId ~= "" and ls.SystemLocaleId)
            or (players.LocalPlayer and players.LocalPlayer.LocaleId)
            or "en-us"
    end)
    if ok and typeof(loc) == "string" then
        loc = string.lower(loc)
        if string.sub(loc, 1, 2) == "ru" then code = "ru" end
    end
    self:SetLanguage(code)
    return code
end

--[[ Notification System ]]

local notificationContainer
local centerContainer

local function setupNotifications()
	if notificationContainer and centerContainer then return end
	local notificationGui = Instance.new("ScreenGui")
	notificationGui.Name = "Eps1llon_Notifications"
	notificationGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	notificationGui.DisplayOrder = 999
	notificationGui.Parent = PlayerGui
	-- Right/bottom stacked toasts container (existing behavior)
	notificationContainer = Instance.new("Frame", notificationGui)
	notificationContainer.Name = "Container"
	notificationContainer.Size = UDim2.new(0, 320, 1, -20)
	notificationContainer.Position = UDim2.new(1, -340, 0, 0)
	notificationContainer.BackgroundTransparency = 1
	local listLayout = Instance.new("UIListLayout", notificationContainer)
	listLayout.Padding = UDim.new(0, 8)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	-- Center pop-up holder for help/explanations
	centerContainer = Instance.new("Frame", notificationGui)
	centerContainer.Name = "CenterContainer"
	centerContainer.Size = UDim2.fromScale(1, 1)
	centerContainer.BackgroundTransparency = 1
end

function Library:Notify(options)
	setupNotifications()
	options = options or {}
	local title = options.Title or "Notification"
	local text = options.Text
	local duration = options.Duration or 5
	local nType = options.Type or "Info"
	local THEME = Library.Theme
	local typeColors = {
		Info = THEME.Info,
		Success = THEME.Success,
		Warning = THEME.Warning,
		Error = THEME.Error,
	}
	local barColor = typeColors[nType] or typeColors.Info
	local notifFrame = Instance.new("Frame")
	notifFrame.Size = UDim2.new(1, 0, 0, 0)
	notifFrame.BackgroundColor3 = THEME.panel
	notifFrame.BackgroundTransparency = 0
	notifFrame.ClipsDescendants = true
	notifFrame.LayoutOrder = tick()
	notifFrame.Position = UDim2.new(0.2, 0, 0, 0)
	Library:_SetGroupTransparency(notifFrame, 1)
	notifFrame.Parent = notificationContainer
	Instance.new("UICorner", notifFrame).CornerRadius = UDim.new(0, 8)
	local stroke = Instance.new("UIStroke", notifFrame)
	stroke.Color = THEME.separator
	stroke.Transparency = 0.94
	stroke.Thickness = 1
	local contentFrame = Instance.new("Frame", notifFrame)
	contentFrame.Size = UDim2.new(1, 0, 1, 0)
	contentFrame.BackgroundTransparency = 1
	local contentLayout = Instance.new("UIListLayout", contentFrame)
	contentLayout.Padding = UDim.new(0, 4)
	contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	contentLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	contentLayout.FillDirection = Enum.FillDirection.Vertical
	local padding = Instance.new("UIPadding", contentFrame)
	padding.PaddingTop = UDim.new(0, 8)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingBottom = UDim.new(0, 8)
	local titleLabel = Instance.new("TextLabel", contentFrame)
	titleLabel.Size = UDim2.new(1, 0, 0, 0)
	titleLabel.AutomaticSize = Enum.AutomaticSize.Y
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Text = title
	titleLabel.TextColor3 = THEME.text
	titleLabel.TextSize = 14
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextWrapped = true
	if text and text ~= "" then
		local textLabel = Instance.new("TextLabel", contentFrame)
		textLabel.Size = UDim2.new(1, 0, 0, 0)
		textLabel.AutomaticSize = Enum.AutomaticSize.Y
		textLabel.BackgroundTransparency = 1
		textLabel.Font = Enum.Font.Gotham
		textLabel.Text = text
		textLabel.TextColor3 = THEME.textDim
		textLabel.TextSize = 11
		textLabel.TextXAlignment = Enum.TextXAlignment.Left
		textLabel.TextWrapped = true
	end
	local timerBar = Instance.new("Frame", notifFrame)
	timerBar.Size = UDim2.new(1, 0, 0, 3)
	timerBar.BackgroundColor3 = barColor
	timerBar.BorderSizePixel = 0
	timerBar.Position = UDim2.new(0, 0, 1, 0)
	timerBar.AnchorPoint = Vector2.new(0, 1)
	RunService.Heartbeat:Wait()
	local targetHeight = contentFrame.UIListLayout.AbsoluteContentSize.Y + padding.PaddingTop.Offset + padding.PaddingBottom.Offset + timerBar.Size.Y.Offset
	notifFrame.Size = UDim2.new(1, 0, 0, targetHeight)
	local appearTweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	local appearTween = TweenService:Create(notifFrame, appearTweenInfo, {
		Position = UDim2.new(0, 0, 0, 0),
	})
	appearTween:Play()
	local appearFade = Library:_TweenGroupTransparency(notifFrame, appearTweenInfo, 0)
	if appearFade then appearFade:Play() end
	local timerTween = TweenService:Create(timerBar, TweenInfo.new(duration, Enum.EasingStyle.Linear), { Size = UDim2.new(0, 0, 0, 3) })
	timerTween:Play()
	timerTween.Completed:Connect(function()
		local disappearTweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
		local disappearTween = TweenService:Create(notifFrame, disappearTweenInfo, {
			Position = UDim2.new(0.2, 0, 0, 0),
		})
		disappearTween:Play()
		local fadeOut = Library:_TweenGroupTransparency(notifFrame, disappearTweenInfo, 1)
		if fadeOut then fadeOut:Play() end
		disappearTween.Completed:Connect(function()
			notifFrame:Destroy()
		end)
	end)
end

-- Center-screen bubble notification used by the section help button
function Library:NotifyCenter(options)
	setupNotifications()
	options = options or {}
	local title = options.Title or "Info"
	local text = options.Text or ""
	local duration = options.Duration or 3.5
	local THEME = Library.Theme

    local bubble = Instance.new("Frame")
	bubble.Name = "CenterBubble"
	bubble.Size = UDim2.new(0, 360, 0, 0)
	bubble.AutomaticSize = Enum.AutomaticSize.Y
    bubble.AnchorPoint = Vector2.new(0.5, 0.5)
    bubble.Position = UDim2.fromScale(0.5, 0.5)
	bubble.BackgroundColor3 = THEME.panel
	Library:_SetGroupTransparency(bubble, 1)
	bubble.Parent = centerContainer
	Instance.new("UICorner", bubble).CornerRadius = UDim.new(0, 10)
	local stroke = Instance.new("UIStroke", bubble)
	stroke.Color = THEME.separator
	stroke.Transparency = 0.92
	stroke.Thickness = 1

	local content = Instance.new("Frame", bubble)
	content.BackgroundTransparency = 1
	content.Size = UDim2.new(1, 0, 1, 0)
	local padding = Instance.new("UIPadding", content)
	padding.PaddingTop = UDim.new(0, 10)
	padding.PaddingBottom = UDim.new(0, 10)
	padding.PaddingLeft = UDim.new(0, 14)
	padding.PaddingRight = UDim.new(0, 14)
	local layout = Instance.new("UIListLayout", content)
	layout.FillDirection = Enum.FillDirection.Vertical
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.Padding = UDim.new(0, 4)

	if title and title ~= "" then
		local titleLabel = Instance.new("TextLabel", content)
		titleLabel.BackgroundTransparency = 1
		titleLabel.AutomaticSize = Enum.AutomaticSize.Y
		titleLabel.Size = UDim2.new(1, 0, 0, 0)
		titleLabel.Font = Enum.Font.GothamBold
		titleLabel.Text = title
		titleLabel.TextColor3 = THEME.text
		titleLabel.TextSize = 14
		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
		titleLabel.TextWrapped = true
	end
	if text and text ~= "" then
		local body = Instance.new("TextLabel", content)
		body.BackgroundTransparency = 1
		body.AutomaticSize = Enum.AutomaticSize.Y
		body.Size = UDim2.new(1, 0, 0, 0)
		body.Font = Enum.Font.Gotham
		body.Text = text
		body.TextColor3 = THEME.textDim
		body.TextSize = 12
		body.TextWrapped = true
		body.TextXAlignment = Enum.TextXAlignment.Left
	end

	-- Appear animation (fade + slight scale pop)
	local scale = Instance.new("UIScale", bubble)
	scale.Scale = 0.92
	RunService.Heartbeat:Wait()
	local appear = TweenService:Create(scale, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 })
	local fadeIn = Library:_TweenGroupTransparency(bubble, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 0)
	appear:Play(); if fadeIn then fadeIn:Play() end

	-- Auto-dismiss
	task.delay(duration, function()
		local fadeOut = Library:_TweenGroupTransparency(bubble, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In), 1)
		local shrink = TweenService:Create(scale, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { Scale = 0.97 })
		shrink:Play(); if fadeOut then fadeOut:Play() end
		fadeOut.Completed:Connect(function()
			bubble:Destroy()
		end)
	end)
end

-- Bottom-of-screen, slide-up explanation toast
function Library:NotifyBottom(options)
    setupNotifications()
    options = options or {}
    local title = options.Title or "Info"
    local text = options.Text or ""
    local duration = options.Duration or 3.5
    local THEME = Library.Theme

    local bubble = Instance.new("Frame")
    bubble.Name = "BottomBubble"
    bubble.Size = UDim2.new(0, 280, 0, 0) -- shorter width
    bubble.AutomaticSize = Enum.AutomaticSize.Y
    bubble.AnchorPoint = Vector2.new(0.5, 1)
    bubble.Position = UDim2.new(0.5, 0, 1, 40) -- start below the screen
    bubble.BackgroundColor3 = THEME.panel
    Library:_SetGroupTransparency(bubble, 1)
    bubble.Parent = centerContainer
    Instance.new("UICorner", bubble).CornerRadius = UDim.new(0, 10)
    local stroke = Instance.new("UIStroke", bubble)
    stroke.Color = THEME.separator
    stroke.Transparency = 0.92
    stroke.Thickness = 1

    local content = Instance.new("Frame", bubble)
    content.BackgroundTransparency = 1
    content.Size = UDim2.new(1, 0, 1, 0)
    local padding = Instance.new("UIPadding", content)
    padding.PaddingTop = UDim.new(0, 14)
    padding.PaddingBottom = UDim.new(0, 14)
    padding.PaddingLeft = UDim.new(0, 14)
    padding.PaddingRight = UDim.new(0, 14)
    local layout = Instance.new("UIListLayout", content)
    layout.FillDirection = Enum.FillDirection.Vertical
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    layout.VerticalAlignment = Enum.VerticalAlignment.Center
    layout.Padding = UDim.new(0, 4)

    if title and title ~= "" then
        local titleLabel = Instance.new("TextLabel", content)
        titleLabel.BackgroundTransparency = 1
        titleLabel.AutomaticSize = Enum.AutomaticSize.Y
        titleLabel.Size = UDim2.new(1, 0, 0, 0)
        titleLabel.Font = Enum.Font.GothamBold
        titleLabel.Text = title
        titleLabel.TextColor3 = THEME.text
        titleLabel.TextSize = 14
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.TextWrapped = true
    end
    if text and text ~= "" then
        local body = Instance.new("TextLabel", content)
        body.BackgroundTransparency = 1
        body.AutomaticSize = Enum.AutomaticSize.Y
        body.Size = UDim2.new(1, 0, 0, 0)
        body.Font = Enum.Font.Gotham
        body.Text = text
        body.TextColor3 = THEME.textDim
        body.TextSize = 12
        body.TextWrapped = true
        body.TextXAlignment = Enum.TextXAlignment.Left
    end

    -- Appear from below the screen
    RunService.Heartbeat:Wait()
    bubble.Position = UDim2.new(0.5, 0, 1, 40)
    local appear = TweenService:Create(bubble, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, 0, 1, -86), -- a bit higher and compact
    })
    appear:Play()
    local appearFade = Library:_TweenGroupTransparency(bubble, TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), 0)
    if appearFade then appearFade:Play() end

    task.delay(duration, function()
        local disappear = TweenService:Create(bubble, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
            Position = UDim2.new(0.5, 0, 1, 40),
        })
        disappear:Play()
        local fadeOut = Library:_TweenGroupTransparency(bubble, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.In), 1)
        if fadeOut then fadeOut:Play() end
        disappear.Completed:Connect(function()
            bubble:Destroy()
        end)
    end)
end

--[[ Main Window Creation ]]

function Library:CreateWindow(title, subtitle)
    local options
    if typeof(title) == "table" then
        options = title
        title = options.Title or options.WindowTitle or options[1] or title
        subtitle = options.Subtitle or options.SubTitle or options.SubtitleText or options.Description or subtitle
    end

    -- Default language is English. Auto-detect only if explicitly requested.
    if options and (options.AutoDetectLanguage or options.ForceAutoLanguage) then
        self:AutoDetectLanguage({ Force = options.ForceAutoLanguage })
    end

    -- Ensure title/subtitle are strings to avoid assigning tables to Text
    title = asText(title, "UI Library")
    subtitle = asText(subtitle, "Premium")

    if options and options.ToggleKey then
        local kc = options.ToggleKey
        if typeof(kc) == "string" then kc = stringToKeycode(kc) end
        if typeof(kc) == "EnumItem" then
            self.Config.ToggleKey = kc
        end
    end

	if options and options.KeySystem ~= nil then
		self:ConfigureKeySystem(options.KeySystem)
	end

	if not self:_EnsureKeySystem() then
		return nil
	end

	if PlayerGui:FindFirstChild("Eps1llonUI_Window") then
		PlayerGui.Eps1llonUI_Window:Destroy()
	end
	local Window = {}
	local THEME = Library.Theme
	local CONFIG = Library.Config
    local HEADER_RIGHT_PADDING = 110
    -- Reserve only space required for a single control (expand) while minimized
    local HEADER_RIGHT_PADDING_MINI = 48
    local MINIMIZED_MIN_WIDTH = 220
	local pages, activePage = {}, nil
	local isVisible = false
	local isAnimating = true
	local FADE_TIME = 0.2
	local mainGui = Instance.new("ScreenGui")
	mainGui.Name = "Eps1llonUI_Window"
	mainGui.ResetOnSpawn = false
	mainGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	mainGui.Parent = PlayerGui
	local guiWidth, guiHeight = 580, 340

	-- Add a subtle outer glow around the UI (very transparent, slightly larger)
    local outerGlow = Instance.new("ImageLabel", mainGui)
    outerGlow.Name = "OuterGlow"
    outerGlow.BackgroundTransparency = 1
    outerGlow.ZIndex = 0
    outerGlow.Image = "rbxassetid://3570695787"
    outerGlow.ScaleType = Enum.ScaleType.Slice
    outerGlow.SliceCenter = Rect.new(100, 100, 100, 100)
    outerGlow.ImageColor3 = THEME.bg
    outerGlow.ImageTransparency = 1 -- disabled outline: hide fill and stroke
    local glowCorner = Instance.new("UICorner", outerGlow)
    glowCorner.CornerRadius = UDim.new(0, 22) -- slightly larger to match the outside expansion
    local glowStroke = Instance.new("UIStroke", outerGlow)
    glowStroke.Color = THEME.bg
    glowStroke.Thickness = 0
    glowStroke.Transparency = 1
    glowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    outerGlow.Visible = false
    local rootFrame = Instance.new("Frame")
	rootFrame.Name = "Root"
    rootFrame.Size = UDim2.fromOffset(guiWidth, guiHeight)
    -- Anchor at top-left so expanding to full screen aligns reliably
    rootFrame.AnchorPoint = Vector2.new(0, 0)
    rootFrame.Position = UDim2.new(0.5, -guiWidth/2, 0.5, -guiHeight/2)
	rootFrame.BackgroundColor3 = THEME.bg
	rootFrame.BackgroundTransparency = 0
	rootFrame.BorderSizePixel = 0
	rootFrame.Parent = mainGui
	rootFrame.ClipsDescendants = true
	Library:_SetGroupTransparency(rootFrame, 1)
	Instance.new("UICorner", rootFrame).CornerRadius = UDim.new(0, 14)

	-- keep the glow frame synced with the window's position/size
	local function syncGlow()
		local absPos = rootFrame.AbsolutePosition
		local absSize = rootFrame.AbsoluteSize
		outerGlow.Position = UDim2.fromOffset(absPos.X - 8, absPos.Y - 8)
		outerGlow.Size = UDim2.fromOffset(absSize.X + 16, absSize.Y + 16)
	end
    -- outline disabled; skip syncing
	local clickToClose = Instance.new("TextButton", rootFrame)
	clickToClose.Name = "ClickToClose"
	clickToClose.Size = UDim2.new(1, 0, 1, 0)
	clickToClose.BackgroundTransparency = 1
	clickToClose.Text = ""
	clickToClose.Visible = false
	clickToClose.ZIndex = 5
	local strokeHolder = Instance.new("Frame", rootFrame)
	strokeHolder.Name = "StrokeHolder"
	strokeHolder.Size = UDim2.new(1, 0, 1, 0)
	strokeHolder.BackgroundTransparency = 1
	Instance.new("UICorner", strokeHolder).CornerRadius = UDim.new(0, 14)
    local rootStroke = Instance.new("UIStroke", strokeHolder)
    rootStroke.Color = Color3.fromRGB(255, 255, 255)
    rootStroke.Transparency = 0.9 -- match separator thinness
    rootStroke.Thickness = 1
    rootStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	local headerHeight, tabsWidth = 44, 140
	local dragFrame = Instance.new("Frame", rootFrame)
	dragFrame.Size = UDim2.new(1, 0, 0, headerHeight)
	dragFrame.BackgroundTransparency = 1
	dragFrame.ZIndex = 2
	local brandLogo = Instance.new("ImageLabel", rootFrame)
	brandLogo.Size = UDim2.fromOffset(24, 24)
	brandLogo.Position = UDim2.fromOffset(12, 10)
	brandLogo.BackgroundTransparency = 1
	brandLogo.Image = "rbxassetid://116553067824026"
	local BRAND_CONTAINER_DEFAULT_SIZE = UDim2.new(1, -HEADER_RIGHT_PADDING, 0, 32)
	local brandContainer = Instance.new("Frame", rootFrame)
	brandContainer.Size = BRAND_CONTAINER_DEFAULT_SIZE
	brandContainer.Position = UDim2.fromOffset(42, 8)
	brandContainer.BackgroundTransparency = 1
	brandContainer.ClipsDescendants = true
    local brandTitlePrimary = Instance.new("TextLabel", brandContainer)
	brandTitlePrimary.Size = UDim2.new(1, 0, 0, 17)
	brandTitlePrimary.BackgroundTransparency = 1
	local _windowTitleRaw = title or "UI Library"
	brandTitlePrimary.Text = Library:_Translate(_windowTitleRaw)
	brandTitlePrimary.TextColor3 = THEME.text
	brandTitlePrimary.TextSize = 17
	brandTitlePrimary.Font = Enum.Font.GothamBold
	brandTitlePrimary.TextXAlignment = Enum.TextXAlignment.Left
	brandTitlePrimary.TextTruncate = Enum.TextTruncate.AtEnd
    local brandSubtitle = Instance.new("TextLabel", brandContainer)
	brandSubtitle.Size = UDim2.new(1, 0, 0, 13)
	brandSubtitle.Position = UDim2.fromOffset(0, 17)
	brandSubtitle.BackgroundTransparency = 1
	local _windowSubtitleRaw = subtitle or "Premium"
	brandSubtitle.Text = Library:_Translate(_windowSubtitleRaw)
	brandSubtitle.TextColor3 = THEME.textDim
	brandSubtitle.TextSize = 11
	brandSubtitle.Font = Enum.Font.GothamSemibold
	brandSubtitle.TextXAlignment = Enum.TextXAlignment.Left
	brandSubtitle.TextTruncate = Enum.TextTruncate.AtEnd
    -- Re-apply on language changes
    Library:_BindLocaleText(brandTitlePrimary, _windowTitleRaw)
    Library:_BindLocaleText(brandSubtitle, _windowSubtitleRaw)
	local horizontalLine = Instance.new("Frame", rootFrame)
	horizontalLine.Size = UDim2.new(1, 0, 0, 1)
	horizontalLine.Position = UDim2.fromOffset(0, headerHeight)
	horizontalLine.BackgroundColor3 = THEME.separator
	horizontalLine.BackgroundTransparency = 0.9
	horizontalLine.BorderSizePixel = 0
    local mainContent = Instance.new("Frame", rootFrame)
    mainContent.Name = "MainContent"
    mainContent.Size = UDim2.new(1, 0, 1, -headerHeight)
    mainContent.Position = UDim2.fromOffset(0, headerHeight)
    mainContent.BackgroundTransparency = 1
    local verticalLine = Instance.new("Frame", mainContent)
    verticalLine.Size = UDim2.new(0, 1, 1, -1) -- stop 1px short so it doesn't cross the top line
    verticalLine.Position = UDim2.fromOffset(tabsWidth, 1) -- begin just under the horizontal line
    verticalLine.BackgroundColor3 = THEME.separator
    verticalLine.BackgroundTransparency = 0.9
    verticalLine.BorderSizePixel = 0
	local tabsContainer = Instance.new("ScrollingFrame", mainContent)
	tabsContainer.Name = "TabsContainer"
	tabsContainer.Size = UDim2.new(0, tabsWidth, 1, 0)
	tabsContainer.Position = UDim2.fromOffset(0, 0)
	tabsContainer.BackgroundTransparency = 1
	tabsContainer.BorderSizePixel = 0
	tabsContainer.ScrollBarThickness = 0
	local listLayout = Instance.new("UIListLayout", tabsContainer)
	listLayout.Padding = UDim.new(0, CONFIG.TabPadding)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	Instance.new("UIPadding", tabsContainer).PaddingTop = UDim.new(0, 10)
	local activeTabIndicator = Instance.new("Frame", mainContent)
	activeTabIndicator.Name = "ActiveTabIndicator"
	activeTabIndicator.Size = UDim2.fromOffset(tabsWidth, 32)
	activeTabIndicator.Position = UDim2.fromOffset(0, headerHeight)
	activeTabIndicator.BackgroundTransparency = 1
	activeTabIndicator.ZIndex = 2
	activeTabIndicator.Visible = false
	local indicatorBG = Instance.new("Frame", activeTabIndicator)
	indicatorBG.Name = "IndicatorBG"
	indicatorBG.BackgroundColor3 = THEME.panelHighlight
	indicatorBG.BorderSizePixel = 0
	indicatorBG.Size = UDim2.new(1, -10, 1, -4)
	indicatorBG.Position = UDim2.new(0.5, 0, 0.5, 0)
	indicatorBG.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorBG.BackgroundTransparency = 0.75
	Instance.new("UICorner", indicatorBG).CornerRadius = UDim.new(0, 6)
    local activeMarker = Instance.new("Frame", activeTabIndicator)
    activeMarker.Name = "ActiveMarker"
    activeMarker.BackgroundColor3 = THEME.accent
    activeMarker.BorderSizePixel = 0
    -- make the blue indicator a bit thicker
    activeMarker.Size = UDim2.fromOffset(2, 18)
    activeMarker.AnchorPoint = Vector2.new(0.5, 0.5)
    activeMarker.Position = UDim2.new(0, 12, 0.5, 0)
    Instance.new("UICorner", activeMarker).CornerRadius = UDim.new(1, 0)
	Library:_RegisterAccent(activeMarker, "BackgroundColor3")
	local pageHost = Instance.new("Frame", mainContent)
	pageHost.Size = UDim2.new(1, -tabsWidth, 1, 0)
	pageHost.Position = UDim2.fromOffset(tabsWidth, 0)
	pageHost.BackgroundTransparency = 1
	pageHost.ClipsDescendants = true
	local dropdownHost = Instance.new("ScrollingFrame", rootFrame)
	dropdownHost.Size = UDim2.new(0, 160, 1, -headerHeight - 20)
	dropdownHost.Position = UDim2.new(1, 10, 0, headerHeight + 10)
	dropdownHost.BackgroundColor3 = THEME.panel
	dropdownHost.BorderSizePixel = 0
	dropdownHost.ZIndex = 10
	dropdownHost.BackgroundTransparency = 0
	dropdownHost.ScrollBarThickness = 2
	dropdownHost.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Instance.new("UICorner", dropdownHost).CornerRadius = UDim.new(0, 8)
	local dropdownStroke = Instance.new("UIStroke", dropdownHost)
	dropdownStroke.Color = THEME.separator
	dropdownStroke.Transparency = 0.9
	dropdownStroke.Thickness = 1
	Instance.new("UIListLayout", dropdownHost).Padding = UDim.new(0, 2)
	local dropdownPadding = Instance.new("UIPadding", dropdownHost)
	dropdownPadding.PaddingTop = UDim.new(0, 8)
	dropdownPadding.PaddingBottom = UDim.new(0, 8)
	dropdownPadding.PaddingLeft = UDim.new(0, 8)
	dropdownPadding.PaddingRight = UDim.new(0, 8)
	local activeDropdown = nil
	local activeContext = nil
	local activeBindEditor = nil
	local function closeActiveDropdown()
		if not activeDropdown then return end
		activeDropdown = nil
		clickToClose.Visible = false

		local closeTween = TweenService:Create(dropdownHost, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Position = UDim2.new(1, 10, 0, headerHeight + 10),
		})
		closeTween:Play()

		closeTween.Completed:Connect(function()
			for _, child in ipairs(dropdownHost:GetChildren()) do
				if child:IsA("GuiObject")
					and not child:IsA("UILayout")
					and not child:IsA("UIPadding")
					and not child:IsA("UIStroke")
					and not child:IsA("UICorner") then
					child:Destroy()
				end
			end
		end)
	end
	local function closeActiveContext()
		if activeContext then pcall(function() activeContext:Destroy() end); activeContext = nil end
		if activeBindEditor then pcall(function() activeBindEditor:Destroy() end); activeBindEditor = nil end
		clickToClose.Visible = false
	end
	clickToClose.Activated:Connect(function()
		closeActiveDropdown()
		closeActiveContext()
	end)
    local headerControls = Instance.new("Frame", rootFrame)
    headerControls.Name = "HeaderControls"
    headerControls.Size = UDim2.new(0, 100, 0, headerHeight)
    local HEADER_CONTROLS_DEFAULT_POS = UDim2.new(1, -HEADER_RIGHT_PADDING, 0, 0)
    local HEADER_CONTROLS_MINI_POS = UDim2.new(1, -HEADER_RIGHT_PADDING_MINI, 0, 0)
    headerControls.Position = HEADER_CONTROLS_DEFAULT_POS
	headerControls.BackgroundTransparency = 1
	headerControls.ZIndex = 3
	local minimizeBtn = Instance.new("ImageButton", headerControls)
	minimizeBtn.Size = UDim2.fromOffset(20, 20)
	minimizeBtn.Position = UDim2.new(0, 10, 0.5, 0)
	minimizeBtn.AnchorPoint = Vector2.new(0, 0.5)
	minimizeBtn.BackgroundTransparency = 1
	minimizeBtn.Image = "rbxassetid://110574729016386"
	minimizeBtn.ImageColor3 = THEME.textDim
    local expandBtn = Instance.new("ImageButton", headerControls)
    expandBtn.Size = UDim2.fromOffset(20, 20)
    -- default: evenly spaced between minimize and close
    expandBtn.Position = UDim2.new(0, 40, 0.5, 0)
	expandBtn.AnchorPoint = Vector2.new(0, 0.5)
	expandBtn.BackgroundTransparency = 1
	expandBtn.Image = "rbxassetid://137817849385475"
	expandBtn.ImageColor3 = THEME.textDim
	local closeBtn = Instance.new("ImageButton", headerControls)
	closeBtn.Size = UDim2.fromOffset(20, 20)
	closeBtn.Position = UDim2.new(0, 70, 0.5, 0)
	closeBtn.AnchorPoint = Vector2.new(0, 0.5)
	closeBtn.BackgroundTransparency = 1
	closeBtn.Image = "rbxassetid://71175513861523"
	closeBtn.ImageColor3 = THEME.textDim
	for _, btn in ipairs({ minimizeBtn, expandBtn, closeBtn }) do
		btn.MouseEnter:Connect(function()
			TweenService:Create(btn, TweenInfo.new(0.2), { ImageColor3 = Color3.new(1, 1, 1) }):Play()
		end)
		btn.MouseLeave:Connect(function()
			TweenService:Create(btn, TweenInfo.new(0.2), { ImageColor3 = THEME.textDim }):Play()
		end)
	end
    local originalSize = UDim2.fromOffset(guiWidth, guiHeight)
    local lastPosition = rootFrame.Position
    local lastSize = originalSize
    local isMinimized = false
    local windowAnimating = false
    local isExpanded = false
    local originalTitleText = nil
    local originalSubtitleText = nil
    local minimizedTitle = asText(options and (options.MinimizedTitle or options.MinTitle), "Eps1llon Hub")
    local minimizedSubtitle = asText(options and (options.MinimizedSubtitle or options.MinSubTitle), "Premium")
	local restoreBtn = Instance.new("Frame", rootFrame)
	restoreBtn.Size = UDim2.fromOffset(30, headerHeight)
	restoreBtn.Position = UDim2.new(1, -40, 0, 0)
	restoreBtn.BackgroundTransparency = 1
	Library:_SetGroupTransparency(restoreBtn, 1)
	restoreBtn.ZIndex = 3
	restoreBtn.Visible = false
	local restoreBtnImage = Instance.new("ImageButton", restoreBtn)
	restoreBtnImage.Size = UDim2.fromOffset(24, 24)
	restoreBtnImage.Position = UDim2.new(0.5, 0, 0.5, 0)
	restoreBtnImage.AnchorPoint = Vector2.new(0.5, 0.5)
	restoreBtnImage.BackgroundTransparency = 1
	restoreBtnImage.Image = "rbxassetid://137817849385475"
	restoreBtnImage.ImageColor3 = THEME.textDim
	restoreBtnImage.MouseEnter:Connect(function()
		TweenService:Create(restoreBtnImage, TweenInfo.new(0.2), { ImageColor3 = Color3.new(1, 1, 1) }):Play()
	end)
	restoreBtnImage.MouseLeave:Connect(function()
		TweenService:Create(restoreBtnImage, TweenInfo.new(0.2), { ImageColor3 = THEME.textDim }):Play()
	end)
    -- helper to play several tweens and fire once all complete
    local function playAllTweens(tweens, onDone)
        local remaining = #tweens
        if remaining == 0 then
            if onDone then onDone() end
            return
        end
        for _, tw in ipairs(tweens) do
            tw.Completed:Connect(function()
                remaining = remaining - 1
                if remaining <= 0 and onDone then onDone() end
            end)
            tw:Play()
        end
    end

    local function setMinimizedState(minimize)
        if isMinimized == minimize then return end
        if windowAnimating then return end
        windowAnimating = true
        isMinimized = minimize
        closeActiveDropdown()
        if isExpanded then
            isExpanded = false
        end
        -- smooth, minimal animation without flicker
        local tweenInfo = TweenInfo.new(0.28, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
        local fadeOutTransparency = 1
        local fadeInTransparency = 0
        local tweens = {}
        if minimize then
            -- Capture originals once
            if not originalTitleText then originalTitleText = brandTitlePrimary.Text end
            if not originalSubtitleText then originalSubtitleText = brandSubtitle.Text end
            -- Replace with compact, brand-first texts
            brandTitlePrimary.Text = minimizedTitle
            brandSubtitle.Text = minimizedSubtitle
            brandSubtitle.Visible = true

            -- Measure minimized title and subtitle for compact width
            local titleSize = TextService:GetTextSize(minimizedTitle, brandTitlePrimary.TextSize, brandTitlePrimary.Font, Vector2.new(10000, 10000))
            local subtitleSize = Vector2.new(0,0)
            if minimizedSubtitle and minimizedSubtitle ~= "" then
                subtitleSize = TextService:GetTextSize(minimizedSubtitle, brandSubtitle.TextSize, brandSubtitle.Font, Vector2.new(10000, 10000))
            end
            local textWidth = math.max(titleSize.X, subtitleSize.X)

            -- Left content starts at ~42px (logo + gap); reserve header controls area on the right
            local leftPadding = 42
            local rightPadding = HEADER_RIGHT_PADDING_MINI
            local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
            local maxMinWidth = math.max(MINIMIZED_MIN_WIDTH, 220)
            local compactCap = 320 -- tighter cap for compact look
            local maxWidth = math.min(compactCap, math.floor(viewport.X - 40))
            -- allow truncation if text is longer than compact cap
            local visibleTextWidth = math.min(textWidth, compactCap - leftPadding - rightPadding)
            local targetWidth = math.clamp(leftPadding + visibleTextWidth + rightPadding, maxMinWidth, maxWidth)

            local dynamicSize = UDim2.fromOffset(targetWidth, headerHeight)
            table.insert(tweens, TweenService:Create(rootFrame, tweenInfo, { Size = dynamicSize }))
            -- Keep brand area reserving space for header controls (expand icon)
            table.insert(tweens, TweenService:Create(brandContainer, tweenInfo, { Size = UDim2.new(1, -HEADER_RIGHT_PADDING_MINI, 0, 32) }))

            -- Keep header controls visible, show only expand while minimized
            headerControls.Visible = true
            minimizeBtn.Visible = false
            expandBtn.Visible = true
            closeBtn.Visible = false
            -- shrink controls container and pin expand to right edge
            headerControls.Size = UDim2.new(0, HEADER_RIGHT_PADDING_MINI, 0, headerHeight)
            expandBtn.Position = UDim2.new(1, -30, 0.5, 0)

            -- We don't need the small restore pill anymore
            restoreBtn.Visible = false
            Library:_SetGroupTransparency(restoreBtn, 1)

            -- Hide main content while minimized
            local tgc1 = Library:_TweenGroupTransparency(mainContent, tweenInfo, fadeOutTransparency)
            if tgc1 then table.insert(tweens, tgc1) end
            -- Keep controls tight and aligned to the right edge while ensuring brand text never overlaps
            table.insert(tweens, TweenService:Create(headerControls, tweenInfo, { Position = HEADER_CONTROLS_MINI_POS }))
        else
            -- Restore original texts
            if originalTitleText then brandTitlePrimary.Text = originalTitleText end
            if originalSubtitleText ~= nil then brandSubtitle.Text = originalSubtitleText end
            table.insert(tweens, TweenService:Create(rootFrame, tweenInfo, { Size = originalSize }))
            local tgc2 = Library:_TweenGroupTransparency(mainContent, tweenInfo, fadeInTransparency)
            if tgc2 then table.insert(tweens, tgc2) end
            headerControls.Visible = true
            minimizeBtn.Visible = true
            expandBtn.Visible = true
            closeBtn.Visible = true
            brandSubtitle.Visible = true
            table.insert(tweens, TweenService:Create(brandContainer, tweenInfo, { Size = BRAND_CONTAINER_DEFAULT_SIZE }))
            -- Restore header controls to their default spot/size
            headerControls.Size = UDim2.new(0, 100, 0, headerHeight)
            expandBtn.Position = UDim2.new(0, 40, 0.5, 0)
            table.insert(tweens, TweenService:Create(headerControls, tweenInfo, { Position = HEADER_CONTROLS_DEFAULT_POS }))
            _delayCompat(tweenInfo.Time, function()
                -- Ensure restore pill stays hidden in normal state
                restoreBtn.Visible = false
                Library:_SetGroupTransparency(restoreBtn, 1)
            end)
        end
        playAllTweens(tweens, function()
            windowAnimating = false
        end)
    end
	minimizeBtn.Activated:Connect(function()
		setMinimizedState(true)
	end)
	restoreBtnImage.Activated:Connect(function()
		setMinimizedState(false)
	end)
    local function toggleExpand()
        if windowAnimating then return end
        windowAnimating = true
        isExpanded = not isExpanded

        local expandTweenInfo = TweenInfo.new(0.34, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
        local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
        local absSize = rootFrame.AbsoluteSize
        local oldW, oldH = absSize.X, absSize.Y

        local targetSize, targetPosition
        if isExpanded then
            -- Save current state
            lastPosition = rootFrame.Position
            lastSize = rootFrame.Size

            local factor = 1.2
            local maxW = math.max(420, math.floor(viewport.X * 0.6))
            local maxH = math.max(300, math.floor(viewport.Y * 0.6))
            local newW = math.min(math.floor(oldW * factor + 0.5), maxW)
            local newH = math.min(math.floor(oldH * factor + 0.5), maxH)
            targetSize = UDim2.fromOffset(newW, newH)

            -- Keep visual center by adjusting offsets for new size
            local newOffsetX = rootFrame.Position.X.Offset + math.floor(oldW/2) - math.floor(newW/2)
            local newOffsetY = rootFrame.Position.Y.Offset + math.floor(oldH/2) - math.floor(newH/2)
            targetPosition = UDim2.new(rootFrame.Position.X.Scale, newOffsetX, rootFrame.Position.Y.Scale, newOffsetY)
        else
            -- Restore to previous size; keep the current visual center in place
            targetSize = lastSize or originalSize
            local curAbs = rootFrame.AbsoluteSize
            local newW = targetSize.X.Offset
            local newH = targetSize.Y.Offset
            local newOffsetX = rootFrame.Position.X.Offset + math.floor(curAbs.X/2) - math.floor(newW/2)
            local newOffsetY = rootFrame.Position.Y.Offset + math.floor(curAbs.Y/2) - math.floor(newH/2)
            targetPosition = UDim2.new(rootFrame.Position.X.Scale, newOffsetX, rootFrame.Position.Y.Scale, newOffsetY)
        end

        targetPositionWindow = targetPosition
        local tween = TweenService:Create(rootFrame, expandTweenInfo, { Size = targetSize, Position = targetPosition })
        tween.Completed:Connect(function()
            windowAnimating = false
            if not isExpanded then
                rootFrame.Position = targetPosition
                targetPositionWindow = targetPosition
                smoothOffset = Vector2.new(targetPosition.X.Offset, targetPosition.Y.Offset)
            end
        end)
        tween:Play()
    end

    expandBtn.Activated:Connect(function()
        -- If minimized, treat this as restore only
        if isMinimized then
            setMinimizedState(false)
            return
        end
        toggleExpand()
    end)
	local draggingWindow, dragInputWindow, frameStartPos, dragStartPos = false, nil, nil, nil
	local targetPositionWindow = rootFrame.Position
	local smoothOffset = Vector2.new(rootFrame.Position.X.Offset, rootFrame.Position.Y.Offset)
	dragFrame.InputBegan:Connect(function(input)
		if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
			draggingWindow = true
			dragInputWindow = input
			frameStartPos = UDim2.new(
				rootFrame.Position.X.Scale,
				math.floor(rootFrame.Position.X.Offset + 0.5),
				rootFrame.Position.Y.Scale,
				math.floor(rootFrame.Position.Y.Offset + 0.5)
			)
			dragStartPos = UserInputService:GetMouseLocation()
			smoothOffset = Vector2.new(frameStartPos.X.Offset, frameStartPos.Y.Offset)
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input == dragInputWindow then
			draggingWindow = false
			local roundedPos = UDim2.new(
				rootFrame.Position.X.Scale,
				math.floor(rootFrame.Position.X.Offset + 0.5),
				rootFrame.Position.Y.Scale,
				math.floor(rootFrame.Position.Y.Offset + 0.5)
			)
			rootFrame.Position = roundedPos
			-- Only persist lastPosition in non-expanded mode (so collapse target is stable)
			if not isExpanded then
				lastPosition = roundedPos
			end
			targetPositionWindow = roundedPos
			smoothOffset = Vector2.new(roundedPos.X.Offset, roundedPos.Y.Offset)
		end
	end)
    RunService.RenderStepped:Connect(function(dt)
        if draggingWindow then
            local mouseDelta = UserInputService:GetMouseLocation() - dragStartPos
            local newPos = UDim2.new(
                frameStartPos.X.Scale,
                frameStartPos.X.Offset + mouseDelta.X,
                frameStartPos.Y.Scale,
                frameStartPos.Y.Offset + mouseDelta.Y
            )
            -- update target only; actual position eases toward this
            targetPositionWindow = newPos
        end
        -- Avoid position updates while animating to prevent visual shaking
        if not windowAnimating then
            local targetOffset = Vector2.new(targetPositionWindow.X.Offset, targetPositionWindow.Y.Offset)
            local delta = targetOffset - smoothOffset
            if delta.Magnitude > 0.001 then
                -- time-aware smoothing for consistent feel (FPS-independent)
                local factor
                local hl = tonumber(CONFIG.DragHalfLife)
                if hl and hl > 0 then
                    -- half-life model: error reduces by 50% every 'hl' seconds
                    factor = 1 - (2 ^ (-((dt or 1/60) / hl)))
                else
                    local k = math.clamp(CONFIG.DragSmoothness, 0, 1)
                    factor = 1 - math.exp(-10 * k * (dt or 1/60))
                end
                smoothOffset = smoothOffset + delta * factor
            else
                smoothOffset = targetOffset
            end
            local finalOffsetX = math.floor(smoothOffset.X + 0.5)
            local finalOffsetY = math.floor(smoothOffset.Y + 0.5)
            rootFrame.Position = UDim2.new(targetPositionWindow.X.Scale, finalOffsetX, targetPositionWindow.Y.Scale, finalOffsetY)
        else
            targetPositionWindow = rootFrame.Position
            smoothOffset = Vector2.new(rootFrame.Position.X.Offset, rootFrame.Position.Y.Offset)
        end
    end)
    UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if Library._captureBlockInput then return end
        -- Toggle keybinds for controls
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local kc = input.KeyCode
            local list = Library._toggleBinds[kc]
            if list then
                for _, b in ipairs(list) do
                    local ok, cur = pcall(b.get)
                    local newVal = not cur
                    if b.type == "Toggle" then
                        pcall(b.set, newVal)
                    end
                end
            end
        end
        if input.KeyCode == CONFIG.ToggleKey then
            if isAnimating then return end
            isAnimating = true
            isVisible = not isVisible
			local tweenInfo = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
			if isVisible then
				mainGui.Enabled = true
				local tween = Library:_TweenGroupTransparency(rootFrame, tweenInfo, 0)
				tween.Completed:Connect(function()
					isAnimating = false
				end)
				tween:Play()
			else
				local tween = Library:_TweenGroupTransparency(rootFrame, tweenInfo, 1)
				tween.Completed:Connect(function()
					if not isVisible then mainGui.Enabled = false end
					isAnimating = false
				end)
				tween:Play()
			end
		end
	end)
	closeBtn.Activated:Connect(function()
		if isAnimating then return end
		isAnimating = true
		local tweenInfo = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local fadeOutTween = Library:_TweenGroupTransparency(rootFrame, tweenInfo, 1)
		fadeOutTween.Completed:Connect(function()
			mainGui:Destroy()
		end)
		fadeOutTween:Play()
	end)
	local function updateActiveIndicator()
		if not activePage or not activePage.button then
			activeTabIndicator.Visible = false
			return
		end
		local btnPos = activePage.button.AbsolutePosition
		local mainPos = mainContent.AbsolutePosition
		local offset = btnPos - mainPos
		activeTabIndicator.Position = UDim2.fromOffset(offset.X, offset.Y)
		activeTabIndicator.Visible = true
	end
	tabsContainer:GetPropertyChangedSignal("CanvasPosition"):Connect(updateActiveIndicator)
	listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateActiveIndicator)
	rootFrame:GetPropertyChangedSignal("AbsolutePosition"):Connect(updateActiveIndicator)
	rootFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateActiveIndicator)
	local function applyPageOrder(order)
		if not pages or #pages == 0 then return end
		local map = {}
		for _, pObj in ipairs(pages) do
			map[pObj.button.Name] = pObj
			map[pObj] = pObj
		end
		local used = {}
		local newOrder = {}
		for _, item in ipairs(order) do
			local pObj = nil
			if typeof(item) == "string" and map[item] then
				pObj = map[item]
			elseif typeof(item) == "table" and map[item] then
				pObj = map[item]
			end
			if pObj and not used[pObj] then
				table.insert(newOrder, pObj)
				used[pObj] = true
			end
		end
		for _, pObj in ipairs(pages) do
			if not used[pObj] then
				table.insert(newOrder, pObj)
			end
		end
		pages = newOrder
		for idx, pObj in ipairs(pages) do
			pObj.button.LayoutOrder = idx
		end
		updateActiveIndicator()
	end
	local function getPageOrder()
		local order = {}
		for _, pObj in ipairs(pages) do
			table.insert(order, pObj.button.Name)
		end
		return order
	end
	function Window:CreatePage(options)
		local Page = {}
		options = options or {}
		local pageTitleRaw = options.Title or "Unnamed Page"
		local pageTitle = Library:_Translate(pageTitleRaw)
		local pageIcon = options.Icon
		local pageCanvas = Instance.new("Frame", pageHost)
		pageCanvas.Size = UDim2.new(1, 0, 1, 0)
		pageCanvas.Position = UDim2.new(0, 0, 0, 0)
		pageCanvas.BackgroundTransparency = 1
		pageCanvas.Visible = false
		Library:_SetGroupTransparency(pageCanvas, 0)
		local pageContainer = Instance.new("ScrollingFrame", pageCanvas)
		pageContainer.Name = pageTitle
		pageContainer.Size = UDim2.new(1, 0, 1, 0)
		pageContainer.BackgroundTransparency = 1
		pageContainer.BorderSizePixel = 0
		pageContainer.ScrollBarThickness = 0
		pageContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
		local pageLayout = Instance.new("UIListLayout", pageContainer)
		pageLayout.Padding = UDim.new(0, 10)
		local p = Instance.new("UIPadding", pageContainer)
		p.PaddingTop = UDim.new(0, 10)
		p.PaddingBottom = UDim.new(0, 10)
		p.PaddingLeft = UDim.new(0, 10)
		p.PaddingRight = UDim.new(0, 10)
		local tabButton = Instance.new("TextButton", tabsContainer)
		tabButton.Name = pageTitle .. "Tab"
		tabButton.Size = UDim2.new(1, 0, 0, 32)
		tabButton.BackgroundTransparency = 1
		tabButton.Text = ""
		tabButton.ZIndex = 3
		tabButton.LayoutOrder = #pages + 1
		local tabLayout = Instance.new("UIListLayout", tabButton)
		tabLayout.FillDirection = Enum.FillDirection.Horizontal
		tabLayout.VerticalAlignment = Enum.VerticalAlignment.Center
		tabLayout.Padding = UDim.new(0, 8)
		local tabPadding = Instance.new("UIPadding", tabButton)
		if pageIcon then
			tabPadding.PaddingLeft = UDim.new(0, 15)
			local icon = Instance.new("ImageLabel", tabButton)
			icon.Name = "Icon"
			icon.Size = UDim2.fromOffset(16, 16)
			icon.BackgroundTransparency = 1
			icon.Image = pageIcon
			icon.LayoutOrder = 1
		else
			tabPadding.PaddingLeft = UDim.new(0, 25)
		end
		local titleLabel = Instance.new("TextLabel", tabButton)
		titleLabel.Name = "TitleLabel"
		titleLabel.AutomaticSize = Enum.AutomaticSize.X
		titleLabel.Size = UDim2.new(0, 0, 1, 0)
		titleLabel.BackgroundTransparency = 1
		titleLabel.Font = Enum.Font.GothamBold
		local displayTitle = (Library.Locale == "en") and toTitleCase(pageTitle) or pageTitle
		titleLabel.Text = displayTitle
		titleLabel.TextColor3 = THEME.textDim
		titleLabel.TextSize = 14
		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
		titleLabel.LayoutOrder = 2
		-- Update page title when language changes
		Library:_onLanguageChanged(function()
			local newTitle = Library:_Translate(pageTitleRaw)
			local disp = (Library.Locale == "en") and toTitleCase(newTitle) or newTitle
			titleLabel.Text = disp
			pageContainer.Name = newTitle
			tabButton.Name = newTitle .. "Tab"
		end)
		local pageObject = { button = tabButton, canvas = pageCanvas, container = pageContainer }
		table.insert(pages, pageObject)
		local function setPageActive(page, isInstant)
			closeActiveDropdown()
			if activePage == page and not isInstant then return end
			local newPage = page
			local prevPage = activePage
			activePage = newPage
			local tweenInfoColor = isInstant and TweenInfo.new(0) or TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			for _, pObj in ipairs(pages) do
				local targetColor = (pObj == newPage) and THEME.textActive or THEME.textDim
				TweenService:Create(pObj.button.TitleLabel, tweenInfoColor, { TextColor3 = targetColor }):Play()
			end
			if prevPage and prevPage.canvas then
				if isInstant then
					prevPage.canvas.Visible = false
					prevPage.canvas.Position = UDim2.new(0, 0, 0, 0)
				else
					prevPage.canvas.Position = UDim2.new(0, 0, 0, 0)
					local slideOut = TweenService:Create(prevPage.canvas, TweenInfo.new(0.32, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Position = UDim2.new(-1, 0, 0, 0) })
					slideOut.Completed:Connect(function()
						if prevPage ~= activePage then
							prevPage.canvas.Visible = false
							prevPage.canvas.Position = UDim2.new(0, 0, 0, 0)
						end
					end)
					slideOut:Play()
				end
			end
			if newPage and newPage.canvas then
				if isInstant then
					newPage.canvas.Visible = true
					newPage.canvas.Position = UDim2.new(0, 0, 0, 0)
				else
					newPage.canvas.Position = UDim2.new(1, 0, 0, 0)
					newPage.canvas.Visible = true
					TweenService:Create(newPage.canvas, TweenInfo.new(0.32, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Position = UDim2.new(0, 0, 0, 0) }):Play()
				end
			end
			if newPage and newPage.button then
				local btnPos = newPage.button.AbsolutePosition
				local mainPos = mainContent.AbsolutePosition
				local offset = btnPos - mainPos
				local targetUDim = UDim2.fromOffset(offset.X, offset.Y)
				if isInstant then
					activeTabIndicator.Position = targetUDim
					activeTabIndicator.Visible = true
				else
					activeTabIndicator.Visible = true
					local indicatorTween = TweenService:Create(activeTabIndicator, TweenInfo.new(0.24, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), { Position = targetUDim })
                    indicatorTween.Completed:Connect(function()
                        if windowAnimating then return end
                        local pulseIn = TweenService:Create(activeMarker, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Size = UDim2.fromOffset(2, 26) })
                        pulseIn.Completed:Connect(function()
                            TweenService:Create(activeMarker, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Size = UDim2.fromOffset(2, 18) }):Play()
                        end)
                        pulseIn:Play()
                    end)
					indicatorTween:Play()
				end
			end
		end
        if #pages == 1 then
            _waitCompat()
            setPageActive(pageObject, true)
        end
		tabButton.MouseEnter:Connect(function()
			if activePage ~= pageObject then
				TweenService:Create(titleLabel, TweenInfo.new(0.2), { TextColor3 = THEME.text }):Play()
			end
		end)
		tabButton.MouseLeave:Connect(function()
			if activePage ~= pageObject then
				TweenService:Create(titleLabel, TweenInfo.new(0.2), { TextColor3 = THEME.textDim }):Play()
			end
		end)
		tabButton.Activated:Connect(function()
			setPageActive(pageObject)
		end)
        function Page:CreateSection(secOptions)
            local Section = {}
            secOptions = secOptions or {}
            local sectionTitle = Library:_Translate(secOptions.Title or "Unnamed Section")
            local sectionIcon = secOptions.Icon
            local sectionHelpText = Library:_Translate(secOptions.HelpText or secOptions.Description or "")
            local expanded = false
			local sectionFrame = Instance.new("Frame", pageContainer)
			sectionFrame.AutomaticSize = Enum.AutomaticSize.Y
			sectionFrame.Size = UDim2.new(1, 0, 0, 0)
			sectionFrame.BackgroundColor3 = THEME.panel
			sectionFrame.BackgroundTransparency = 0.7
			sectionFrame.BorderSizePixel = 0
			Instance.new("UICorner", sectionFrame).CornerRadius = UDim.new(0, 6)
            local sectionStroke = Instance.new("UIStroke", sectionFrame)
            sectionStroke.Color = THEME.separator
            sectionStroke.Transparency = 0.9
            sectionStroke.Thickness = 1
            sectionStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			local layout = Instance.new("UIListLayout", sectionFrame)
			layout.SortOrder = Enum.SortOrder.LayoutOrder
			local header = Instance.new("TextButton", sectionFrame)
			header.Name = "Header"
			header.Size = UDim2.new(1, 0, 0, 34)
			header.BackgroundTransparency = 1
			header.Text = ""
			header.LayoutOrder = 1
			if sectionIcon then
				local icon = Instance.new("ImageLabel", header)
				icon.Size = UDim2.fromOffset(16, 16)
				icon.Position = UDim2.new(0, 15, 0.5, 0)
				icon.AnchorPoint = Vector2.new(0, 0.5)
				icon.BackgroundTransparency = 1
				icon.Image = sectionIcon
			end
            local titleLabel2 = Instance.new("TextLabel", header)
            local titleXOffset = sectionIcon and 38 or 15
            titleLabel2.Size = UDim2.new(1, -(titleXOffset + 25), 1, 0)
            titleLabel2.Position = UDim2.fromOffset(titleXOffset, 0)
            titleLabel2.BackgroundTransparency = 1
            titleLabel2.Font = Enum.Font.GothamBold
            titleLabel2.Text = sectionTitle
            titleLabel2.TextColor3 = THEME.text
            titleLabel2.TextSize = 14
            titleLabel2.TextXAlignment = Enum.TextXAlignment.Left
            -- Bind section header to language changes
            Library:_BindLocaleText(titleLabel2, secOptions.Title or "Unnamed Section")
            -- Replace hover fingerprint with a help box that shows when expanded
			local helpBtn = Instance.new("TextButton", header)
			local helpBtnConnected = false
			helpBtn.Name = "HelpButton"
			helpBtn.Size = UDim2.fromOffset(16, 16)
			helpBtn.Position = UDim2.new(1, -12, 0.5, 0)
			helpBtn.AnchorPoint = Vector2.new(1, 0.5)
		helpBtn.AutoButtonColor = false
		helpBtn.BackgroundColor3 = THEME.panel -- match section base color
		helpBtn.BackgroundTransparency = 0.6 -- very close to section (0.7), just a touch different
			helpBtn.Text = ""
			helpBtn.Visible = false
			Instance.new("UICorner", helpBtn).CornerRadius = UDim.new(0, 4)
			local helpStroke = Instance.new("UIStroke", helpBtn)
			helpStroke.Color = THEME.separator -- match other widgets
			helpStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			helpStroke.LineJoinMode = Enum.LineJoinMode.Round
			helpStroke.Thickness = 0.5 -- same thinness as multiselect
			helpStroke.Transparency = 0.95 -- a bit more transparent
			local iconImg = Instance.new("ImageLabel", helpBtn)
			iconImg.BackgroundTransparency = 1
			iconImg.Size = UDim2.fromOffset(12, 12)
			iconImg.AnchorPoint = Vector2.new(0.5, 0.5)
			iconImg.Position = UDim2.fromScale(0.5, 0.5)
			iconImg.Image = "rbxassetid://80209557780292"
			iconImg.ImageColor3 = THEME.text
			iconImg.ImageTransparency = 0.05
			local helpScale = Instance.new("UIScale", helpBtn)
			helpScale.Scale = 0.96

			-- Fingerprint icon shown when section is collapsed
			local collapsedIcon = Instance.new("ImageLabel", header)
			collapsedIcon.Name = "CollapsedFingerprint"
			collapsedIcon.Size = UDim2.fromOffset(16, 16)
			collapsedIcon.Position = UDim2.new(1, -12, 0.5, 0)
			collapsedIcon.AnchorPoint = Vector2.new(1, 0.5)
			collapsedIcon.BackgroundTransparency = 1
			collapsedIcon.Image = "rbxassetid://125804091911528"
			-- Fingerprint default state: darker, then light up on hover
			local FP_DEFAULT_COLOR = THEME.textDim
			local FP_DEFAULT_TRANSP = 0.30
			local FP_HOVER_COLOR = THEME.text
			local FP_HOVER_TRANSP = 0.05
			collapsedIcon.ImageColor3 = FP_DEFAULT_COLOR
			collapsedIcon.ImageTransparency = FP_DEFAULT_TRANSP
			collapsedIcon.ZIndex = 2
			collapsedIcon.Visible = true

			local hoverTI = TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			-- Hover: brighten fingerprint only when collapsed
			header.MouseEnter:Connect(function()
				if not expanded and collapsedIcon.Visible then
					TweenService:Create(collapsedIcon, hoverTI, {
						ImageColor3 = FP_HOVER_COLOR,
						ImageTransparency = FP_HOVER_TRANSP,
					}):Play()
				end
			end)
			header.MouseLeave:Connect(function()
				if not expanded and collapsedIcon.Visible then
					TweenService:Create(collapsedIcon, hoverTI, {
						ImageColor3 = FP_DEFAULT_COLOR,
						ImageTransparency = FP_DEFAULT_TRANSP,
					}):Play()
				end
			end)
			local separator = Instance.new("Frame", sectionFrame)
			separator.LayoutOrder = 2
			separator.Size = UDim2.new(1, 0, 0, 1)
			separator.BackgroundColor3 = THEME.separator
			separator.BackgroundTransparency = 0.9
			separator.BorderSizePixel = 0
			separator.Visible = false
            local contentFrame = Instance.new("Frame", sectionFrame)
            contentFrame.Name = "Content"
            contentFrame.Size = UDim2.new(1, 0, 0, 0)
            contentFrame.BackgroundTransparency = 1
            contentFrame.ClipsDescendants = true
            contentFrame.LayoutOrder = 3
            local contentLayout = Instance.new("UIListLayout", contentFrame)
            contentLayout.Padding = UDim.new(0, 8)
            local contentPadding = Instance.new("UIPadding", contentFrame)
            contentPadding.PaddingTop = UDim.new(0, 8)
            contentPadding.PaddingLeft = UDim.new(0, 15)
            contentPadding.PaddingRight = UDim.new(0, 15)
            contentPadding.PaddingBottom = UDim.new(0, 12)
            header.Activated:Connect(function()
                expanded = not expanded
                separator.Visible = expanded
                local contentSize = contentLayout.AbsoluteContentSize.Y + contentPadding.PaddingTop.Offset + contentPadding.PaddingBottom.Offset
                local targetSize = expanded and UDim2.new(1, 0, 0, contentSize) or UDim2.new(1, 0, 0, 0)
                -- scale the animation duration with content size for smoother, synchronized opening
                local duration = math.clamp(0.25 + (contentSize / 600), 0.3, 0.7)
                local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
                TweenService:Create(contentFrame, tweenInfo, { Size = targetSize }):Play()
                -- Show/Hide the help button and fade fingerprint in sync when section expands/collapses
                if expanded then
                    -- Fade out fingerprint
                    if collapsedIcon.Visible then
                        local outTI = TweenInfo.new(math.min(duration * 0.5, 0.28), Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                        TweenService:Create(collapsedIcon, outTI, {
                            ImageTransparency = 1,
                            ImageColor3 = FP_DEFAULT_COLOR,
                        }):Play()
                        task.delay(outTI.Time, function()
                            if expanded then
                                collapsedIcon.Visible = false
                                -- reset to default for next collapse
                                collapsedIcon.ImageColor3 = FP_DEFAULT_COLOR
                                collapsedIcon.ImageTransparency = FP_DEFAULT_TRANSP
                            end
                        end)
                    end
                    -- Fade in help/question mark
                    helpBtn.Visible = true
                    helpScale.Scale = 0.92
                    helpBtn.BackgroundTransparency = 1
                    iconImg.ImageTransparency = 1
                    helpStroke.Transparency = 0.95
					local tiIn = TweenInfo.new(math.min(duration * 0.5, 0.28), Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
					TweenService:Create(helpBtn, tiIn, { BackgroundTransparency = 0.6 }):Play()
                    TweenService:Create(iconImg, tiIn, { ImageTransparency = 0.05 }):Play()
                    TweenService:Create(helpScale, TweenInfo.new(tiIn.Time, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1 }):Play()
                else
                    -- Fade out help/question mark
                    local tiOut = TweenInfo.new(math.min(duration * 0.45, 0.26), Enum.EasingStyle.Quad, Enum.EasingDirection.In)
                    local fadeOut = TweenService:Create(helpBtn, tiOut, { BackgroundTransparency = 1 })
                    local iconFade = TweenService:Create(iconImg, tiOut, { ImageTransparency = 1 })
                    local shrink = TweenService:Create(helpScale, TweenInfo.new(tiOut.Time, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { Scale = 0.96 })
                    shrink:Play(); iconFade:Play(); fadeOut:Play()
                    fadeOut.Completed:Connect(function()
                        helpBtn.Visible = false
                    end)
                    -- Fade fingerprint back in to darker default
                    collapsedIcon.Visible = true
                    collapsedIcon.ImageTransparency = 1
                    collapsedIcon.ImageColor3 = FP_DEFAULT_COLOR
                    TweenService:Create(collapsedIcon, tiOut, {
                        ImageTransparency = FP_DEFAULT_TRANSP,
                        ImageColor3 = FP_DEFAULT_COLOR,
                    }):Play()
                end

                -- Clicking the help button shows a centered animated bubble
                if not helpBtnConnected then
                    helpBtnConnected = true
                    helpBtn.Activated:Connect(function()
                        -- Tap/click feedback
                        local pulse1 = TweenService:Create(helpScale, TweenInfo.new(0.12, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Scale = 1.06 })
                        pulse1.Completed:Connect(function()
                            TweenService:Create(helpScale, TweenInfo.new(0.12, Enum.EasingStyle.Back, Enum.EasingDirection.In), { Scale = 1 }):Play()
                        end)
                        pulse1:Play()

                        local text = sectionHelpText
                        if text == nil or text == "" then
                            text = ""
                        end
                        Library:NotifyBottom({ Title = sectionTitle, Text = text, Duration = 3.5 })
                    end)
                end

                -- If expanding near the bottom, gently scroll to reveal new content fully
                if expanded then
                    _delayCompat(0.02, function()
                        local scroller = pageContainer -- from outer scope
                        if scroller and scroller:IsA("ScrollingFrame") then
                            local bottom = sectionFrame.AbsolutePosition.Y + contentSize + 34 - scroller.AbsolutePosition.Y
                            local overflow = bottom - scroller.AbsoluteSize.Y
                            if overflow > 0 then
                                local target = Vector2.new(scroller.CanvasPosition.X, overflow + 12)
                                local t = 0
                                local start = scroller.CanvasPosition
                                local dur = math.clamp(duration, 0.2, 0.6)
                                local conn
                                conn = RunService.RenderStepped:Connect(function(dt)
                                    t = math.min(t + dt, dur)
                                    local alpha = t / dur
                                    scroller.CanvasPosition = start:Lerp(target, alpha)
                                    if t >= dur and conn then conn:Disconnect() end
                                end)
                            end
                        end
                    end)
                end
            end)

            -- Compact center-labeled divider:  ---- Title ----
            function Section:CreateDivider(opts)
                opts = opts or {}
                local rawName = opts.Title or opts.Label or "Divider"

                local holder = Instance.new("Frame", contentFrame)
                holder.Size = UDim2.new(1, 0, 0, 12) -- slightly tighter height
                holder.BackgroundTransparency = 1
                holder.ClipsDescendants = false

                local label = Instance.new("TextLabel", holder)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.GothamBold -- match section header font
                label.TextSize = 12               -- slightly smaller than section
                label.Text = Library:_Translate(rawName)
                label.TextColor3 = THEME.textDim
                label.TextXAlignment = Enum.TextXAlignment.Center
                label.AnchorPoint = Vector2.new(0.5, 0.5)
                label.Position = UDim2.new(0.5, 0, 0.5, 0)
                label.ZIndex = 2
                Library:_BindLocaleText(label, rawName)

                local leftLine = Instance.new("Frame", holder)
                leftLine.Name = "LeftLine"
                leftLine.AnchorPoint = Vector2.new(0, 0.5)
                leftLine.Position = UDim2.new(0, 0, 0.5, 0)
                leftLine.Size = UDim2.new(0.5, -40, 0, 1)
                leftLine.BackgroundColor3 = THEME.separator
                leftLine.BackgroundTransparency = 0.85
                leftLine.BorderSizePixel = 0

                local rightLine = Instance.new("Frame", holder)
                rightLine.Name = "RightLine"
                rightLine.AnchorPoint = Vector2.new(1, 0.5)
                rightLine.Position = UDim2.new(1, 0, 0.5, 0)
                rightLine.Size = UDim2.new(0.5, -40, 0, 1)
                rightLine.BackgroundColor3 = THEME.separator
                rightLine.BackgroundTransparency = 0.85
                rightLine.BorderSizePixel = 0

                -- Keep the text visually centered and extend the lines a bit
                local gap = (opts.Gap ~= nil) and opts.Gap or 8     -- space from text to each line
                local extend = (opts.Extend ~= nil) and opts.Extend or 10 -- make lines a little longer
                local function adjust()
                    local absW = holder.AbsoluteSize.X
                    if absW <= 0 then return end
                    local textW = math.floor(label.TextBounds.X + 0.5)
                    local lineW = math.max(0, math.floor((absW - textW) * 0.5 - gap + extend))
                    leftLine.Size = UDim2.new(0, lineW, 0, 1)
                    rightLine.Size = UDim2.new(0, lineW, 0, 1)
                end

                -- adjust when text or size changes
                label:GetPropertyChangedSignal("TextBounds"):Connect(adjust)
                holder:GetPropertyChangedSignal("AbsoluteSize"):Connect(adjust)
                _deferCompat(adjust)

                local obj = { Object = holder }
                obj.SetTitle = function(v)
                    label.Text = tostring(v)
                    adjust()
                end
                return obj
            end
            function Section:CreateImage(opts)
				opts = opts or {}
				local imageAsset = opts.Asset
				if not imageAsset then return end
				local height = opts.Height or 120
				local imageHolder = Instance.new("Frame", contentFrame)
				imageHolder.Size = UDim2.new(1, 0, 0, height)
				imageHolder.BackgroundTransparency = 1
				local image = Instance.new("ImageLabel", imageHolder)
				image.Size = UDim2.new(1, 0, 1, 0)
				image.BackgroundTransparency = 1
				image.Image = imageAsset
				image.ScaleType = Enum.ScaleType.Fit
				Instance.new("UICorner", image).CornerRadius = UDim.new(0, 6)

				return { Object = image, Call = function() end }
			end
            function Section:CreateSlider(opts)
                opts = opts or {}
				local sliderHolder = Instance.new("Frame", contentFrame)
				sliderHolder.Size = UDim2.new(1, 0, 0, 38)
				sliderHolder.BackgroundTransparency = 1
				local topRow = Instance.new("Frame", sliderHolder)
				topRow.Size = UDim2.new(1, 0, 0, 18)
				topRow.BackgroundTransparency = 1
                local titleSlider = Instance.new("TextLabel", topRow)
                titleSlider.Size = UDim2.new(0.5, 0, 1, 0)
                titleSlider.BackgroundTransparency = 1
                titleSlider.Font = Enum.Font.GothamSemibold
                titleSlider.Text = Library:_Translate(opts.Title or "Slider")
                titleSlider.TextColor3 = THEME.text
                titleSlider.TextSize = 13
                titleSlider.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleSlider, opts.Title or "Slider")
				local valueLabel = Instance.new("TextLabel", topRow)
				valueLabel.Size = UDim2.new(0.5, 0, 1, 0)
				valueLabel.Position = UDim2.new(0.5, 0, 0, 0)
				valueLabel.BackgroundTransparency = 1
				valueLabel.Font = Enum.Font.Gotham
				valueLabel.TextColor3 = THEME.textDim
				valueLabel.TextSize = 13
				valueLabel.TextXAlignment = Enum.TextXAlignment.Right
				local track = Instance.new("Frame", sliderHolder)
				track.Size = UDim2.new(1, 0, 0, 6)
				track.Position = UDim2.new(0, 0, 0, 20)
				track.BackgroundColor3 = THEME.panelHighlight
				track.BorderSizePixel = 0
				Instance.new("UICorner", track).CornerRadius = UDim.new(1, 0)
				local fill = Instance.new("Frame", track)
				fill.BackgroundColor3 = THEME.accent
				fill.BorderSizePixel = 0
				Instance.new("UICorner", fill).CornerRadius = UDim.new(1, 0)
				Library:_RegisterAccent(fill, "BackgroundColor3")
				Library:_RegisterAccent(fill, "BackgroundColor3")
				Library:_RegisterAccent(fill, "BackgroundColor3")
				local knob = Instance.new("ImageLabel", track)
				knob.Size = UDim2.fromOffset(14, 14)
				knob.AnchorPoint = Vector2.new(0.5, 0.5)
				knob.Position = UDim2.new(0, 0, 0.5, 0)
				knob.BackgroundTransparency = 1
				knob.Image = "rbxassetid://3570695787"
				knob.ImageColor3 = THEME.textActive
				local minVal, maxVal, defaultVal, decimals = opts.Min or 0, opts.Max or 100, opts.Default or 50, opts.Decimals or 0
				defaultVal = Library:_GetSetting(opts.SaveKey, defaultVal)
				local currentValue, targetPercentage, currentPercentage = defaultVal, (defaultVal - minVal) / (maxVal - minVal), (defaultVal - minVal) / (maxVal - minVal)
				local draggingSlider = false
				local format = "%." .. decimals .. "f"
				local function UpdateVisuals(percentage)
					local value = minVal + (maxVal - minVal) * percentage
					fill.Size = UDim2.new(percentage, 0, 1, 0)
					knob.Position = UDim2.new(percentage, 0, 0.5, 0)
					valueLabel.Text = string.format(format, value)
					if currentValue ~= value then
						currentValue = value
						if opts.Callback and not Library._suppressCallbacks then opts.Callback(value) end
						if opts.SaveKey then
							Library:_SaveSetting(opts.SaveKey, value)
						end
					end
				end
				RunService.Heartbeat:Connect(function()
					if currentPercentage ~= targetPercentage then
						currentPercentage = currentPercentage + (targetPercentage - currentPercentage) * 0.1
						if math.abs(currentPercentage - targetPercentage) < 0.001 then currentPercentage = targetPercentage end
						UpdateVisuals(currentPercentage)
					end
				end)
				track.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = true
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputChanged:Connect(function(input)
					if draggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = false
					end
				end)
				UpdateVisuals(currentPercentage)

				local sliderObject = {}
				sliderObject.Object = sliderHolder
				sliderObject.GetValue = function()
					return currentValue
				end
				sliderObject.SetNumber = function(setval)
					setval = math.clamp(setval, minVal, maxVal)
					local percentage = (setval - minVal) / (maxVal - minVal)
					targetPercentage = percentage
					currentPercentage = percentage 
					UpdateVisuals(percentage)
                    if opts.Callback and not Library._suppressCallbacks then opts.Callback(setval) end
				end
				sliderObject.Call = function(val)
					local value = val or currentValue
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(value) end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = sliderObject
				end
				return sliderObject
			end
            function Section:CreateCheckbox(opts)
                opts = opts or {}
				local checked = Library:_GetSetting(opts.SaveKey, opts.Default or false)
				local holder = Instance.new("TextButton", contentFrame)
				holder.Size = UDim2.new(1, 0, 0, 26)
				holder.BackgroundTransparency = 1
				holder.Text = ""
				local titleCheck = Instance.new("TextLabel", holder)
				titleCheck.Size = UDim2.new(1, -30, 1, 0)
				titleCheck.BackgroundTransparency = 1
                titleCheck.Font = Enum.Font.GothamSemibold
                titleCheck.Text = Library:_Translate(opts.Title or "Checkbox")
                titleCheck.TextColor3 = THEME.text
                titleCheck.TextSize = 13
                titleCheck.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleCheck, opts.Title or "Checkbox")
				local box = Instance.new("Frame", holder)
				box.Size = UDim2.fromOffset(18, 18)
				box.Position = UDim2.new(1, 0, 0.5, 0)
				box.AnchorPoint = Vector2.new(1, 0.5)
				box.BackgroundColor3 = THEME.accent
				box.BackgroundTransparency = 1
				Instance.new("UICorner", box).CornerRadius = UDim.new(0, 4)
				local strokeCheck = Instance.new("UIStroke", box)
				strokeCheck.Color = THEME.separator
				strokeCheck.Transparency = 0.8
				strokeCheck.Thickness = 0.5
				local checkmark = Instance.new("ImageLabel", box)
				checkmark.Size = UDim2.new(1, -4, 1, -4)
				checkmark.Position = UDim2.new(0.5, 0, 0.5, 0)
				checkmark.AnchorPoint = Vector2.new(0.5, 0.5)
				checkmark.BackgroundTransparency = 1
				checkmark.Image = "rbxassetid://101733655234124"
				checkmark.ImageColor3 = THEME.textActive
				checkmark.ImageTransparency = 1
				local function UpdateCheckbox(state, isInstant)
					checked = state
					local tweenInfo = isInstant and TweenInfo.new(0) or TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
					local targetBgTransparency = checked and 0 or 1
					local targetCheckTransparency = checked and 0 or 1
					local targetStrokeTransparency = checked and 1 or 0.8
					TweenService:Create(box, tweenInfo, { BackgroundTransparency = targetBgTransparency }):Play()
					TweenService:Create(checkmark, tweenInfo, { ImageTransparency = targetCheckTransparency }):Play()
					TweenService:Create(strokeCheck, tweenInfo, { Transparency = targetStrokeTransparency }):Play()
					if opts.Callback and not isInstant and not Library._suppressCallbacks then
						opts.Callback(checked)
					end
					if opts.SaveKey and not isInstant then
						Library:_SaveSetting(opts.SaveKey, checked)
					end
				end
				holder.Activated:Connect(function()
					UpdateCheckbox(not checked)
				end)
				UpdateCheckbox(checked, true)

				local checkboxObject = {}
				checkboxObject.Object = holder
				checkboxObject.GetState = function()
					return checked
				end
				checkboxObject.SetState = function(v)
					UpdateCheckbox(v, false) -- [[ Ð˜Ð—ÐœÐ•ÐÐ•ÐÐž ]] -- Ð£Ð±ÐµÐ¶Ð´Ð°ÐµÐ¼ÑÑ, Ñ‡Ñ‚Ð¾ isInstant = false, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Callback
				end
				checkboxObject.Call = function(val)
					local v = (val ~= nil) and val or checked
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(v) end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = checkboxObject
				end
				return checkboxObject
			end
            function Section:CreateToggle(opts)
                opts = opts or {}
				local toggled = Library:_GetSetting(opts.SaveKey, opts.Default or false)
				local holderToggle = Instance.new("TextButton", contentFrame)
				holderToggle.Size = UDim2.new(1, 0, 0, 26)
				holderToggle.BackgroundTransparency = 1
				holderToggle.Text = ""
				local titleToggle = Instance.new("TextLabel", holderToggle)
				titleToggle.Size = UDim2.new(1, -50, 1, 0)
				titleToggle.BackgroundTransparency = 1
                titleToggle.Font = Enum.Font.GothamSemibold
                titleToggle.Text = Library:_Translate(opts.Title or "Toggle")
                titleToggle.TextColor3 = THEME.text
                titleToggle.TextSize = 13
                titleToggle.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleToggle, opts.Title or "Toggle")

				-- optional keybind/context menu opener
				local menuBtn
				if opts.Keybindable then
					menuBtn = Instance.new("TextButton", holderToggle)
					menuBtn.Size = UDim2.fromOffset(22, 22)
					menuBtn.Position = UDim2.new(0, 2, 0.5, 0)
					menuBtn.AnchorPoint = Vector2.new(0, 0.5)
					menuBtn.Text = "..."
					menuBtn.Font = Enum.Font.GothamBold
					menuBtn.TextSize = 12
					menuBtn.TextColor3 = THEME.textDim
					menuBtn.BackgroundColor3 = THEME.panelHighlight
					menuBtn.BackgroundTransparency = 0.5
					Instance.new("UICorner", menuBtn).CornerRadius = UDim.new(0, 6)
					local mStroke = Instance.new("UIStroke", menuBtn)
					mStroke.Color = THEME.separator
					mStroke.Transparency = 0.9
					mStroke.Thickness = 1
					-- shift title to make space for button
					titleToggle.Position = UDim2.fromOffset(26, 0)
					titleToggle.Size = UDim2.new(1, -50-26, 1, 0)
				end
				local trackToggle = Instance.new("Frame", holderToggle)
				trackToggle.Size = UDim2.fromOffset(36, 18)
				trackToggle.Position = UDim2.new(1, 0, 0.5, 0)
				trackToggle.AnchorPoint = Vector2.new(1, 0.5)
				trackToggle.BackgroundColor3 = THEME.panelHighlight
				Instance.new("UICorner", trackToggle).CornerRadius = UDim.new(1, 0)
				local thumb = Instance.new("Frame", trackToggle)
				thumb.Size = UDim2.fromOffset(14, 14)
				thumb.AnchorPoint = Vector2.new(0.5, 0.5)
				thumb.BackgroundColor3 = THEME.textActive
				Instance.new("UICorner", thumb).CornerRadius = UDim.new(1, 0)
                local function UpdateToggle(state, isInstant)
                    toggled = state
                    local tweenInfo = isInstant and TweenInfo.new(0) or TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local targetTrackColor = toggled and THEME.accent or THEME.panelHighlight
                    local targetThumbPos = toggled and UDim2.new(1, -9, 0.5, 0) or UDim2.new(0, 9, 0.5, 0)
                    TweenService:Create(trackToggle, tweenInfo, { BackgroundColor3 = targetTrackColor }):Play()
                    TweenService:Create(thumb, tweenInfo, { Position = targetThumbPos }):Play()
                    if opts.Callback and not isInstant and not Library._suppressCallbacks then
                        opts.Callback(toggled)
                    end
                    if opts.SaveKey and not isInstant then
                        Library:_SaveSetting(opts.SaveKey, toggled)
                    end
                end
                Library:_OnAccentChanged(function()
                    UpdateToggle(toggled, true)
                end)
				holderToggle.Activated:Connect(function()
					UpdateToggle(not toggled)
				end)
				UpdateToggle(toggled, true)

				-- keybind registry helpers
				local boundKC = nil
				local bindType = "Toggle"
				local bindId = tostring(holderToggle)
				local function _removeFromKey(kc)
					if not kc then return end
					local list = Library._toggleBinds[kc]
					if not list then return end
					for i=#list,1,-1 do
						if list[i] and list[i].id == bindId then table.remove(list, i) end
					end
					if #list == 0 then Library._toggleBinds[kc] = nil end
				end
				local function _addToKey(kc)
					if not kc then return end
					Library._toggleBinds[kc] = Library._toggleBinds[kc] or {}
					table.insert(Library._toggleBinds[kc], {
						id = bindId,
						type = bindType,
						get = function() return toggled end,
						set = function(v) UpdateToggle(v, false) end,
					})
				end
				local function SetBindKey(kc)
					_removeFromKey(boundKC)
					boundKC = kc
					_addToKey(boundKC)
				end

				-- context menu + bind editor
				if menuBtn then
					local function openBindEditor(anchor)
						if activeBindEditor then activeBindEditor:Destroy(); activeBindEditor=nil end
						local panel = Instance.new("Frame", rootFrame)
						panel.ZIndex = 12
						panel.BackgroundColor3 = THEME.panel
						panel.BackgroundTransparency = 0
						panel.Size = UDim2.fromOffset(220, 120)
						panel.Position = UDim2.fromOffset(anchor.X + 170, anchor.Y)
						Instance.new("UICorner", panel).CornerRadius = UDim.new(0, 8)
						local pStroke = Instance.new("UIStroke", panel)
						pStroke.Color = THEME.separator
						pStroke.Transparency = 0.9
						pStroke.Thickness = 1
						local pad = Instance.new("UIPadding", panel)
						pad.PaddingTop = UDim.new(0,8); pad.PaddingBottom = UDim.new(0,8); pad.PaddingLeft = UDim.new(0,10); pad.PaddingRight = UDim.new(0,10)
						local y = 8
						local function row(label)
							local t = Instance.new("TextLabel", panel)
							t.Size = UDim2.new(0.4, -8, 0, 20)
							t.Position = UDim2.fromOffset(10, y)
							t.BackgroundTransparency = 1
							t.Font = Enum.Font.GothamSemibold
							t.Text = label
							t.TextColor3 = THEME.text
							t.TextSize = 13
							t.TextXAlignment = Enum.TextXAlignment.Left
							return t
						end
						row("Key")
						local keyBtn = Instance.new("TextButton", panel)
						keyBtn.Size = UDim2.new(0.55, 0, 0, 20)
						keyBtn.Position = UDim2.new(0.45, 0, 0, y)
						keyBtn.BackgroundColor3 = THEME.panelHighlight
						keyBtn.BackgroundTransparency = 0.5
						keyBtn.Text = boundKC and keycodeToString(boundKC) or "None"
						keyBtn.Font = Enum.Font.Gotham
						keyBtn.TextSize = 12
						keyBtn.TextColor3 = THEME.textDim
						Instance.new("UICorner", keyBtn).CornerRadius = UDim.new(0, 6)
						local kStroke = Instance.new("UIStroke", keyBtn)
						kStroke.Color = THEME.separator; kStroke.Transparency = 0.85; kStroke.Thickness = 1
						local listening = false
						local conn
						local function finish(kc)
							if kc then
								SetBindKey(kc)
								keyBtn.Text = keycodeToString(kc)
							end
							listening=false
							Library._captureBlockInput=false
							if conn then conn:Disconnect() end
						end
						keyBtn.Activated:Connect(function()
							if listening then return end
							listening=true
							Library._captureBlockInput=true
							keyBtn.Text = "Press a key..."
							conn = UserInputService.InputBegan:Connect(function(input, gp)
								if gp then return end
								if input.UserInputType == Enum.UserInputType.Keyboard then
									local kc = input.KeyCode
									if kc and kc ~= Enum.KeyCode.Unknown then
										finish(kc)
									end
								end
							end)
						end)
						y = y + 26
						row("Type")
						local typeBtn = Instance.new("TextButton", panel)
						typeBtn.Size = UDim2.new(0.55, 0, 0, 20)
						typeBtn.Position = UDim2.new(0.45, 0, 0, y)
						typeBtn.BackgroundColor3 = THEME.panelHighlight
						typeBtn.BackgroundTransparency = 0.5
						typeBtn.Text = bindType
						typeBtn.Font = Enum.Font.Gotham
						typeBtn.TextSize = 12
						typeBtn.TextColor3 = THEME.textDim
						Instance.new("UICorner", typeBtn).CornerRadius = UDim.new(0, 6)
						typeBtn.Activated:Connect(function()
							bindType = (bindType == "Toggle") and "Toggle" or "Toggle"
							typeBtn.Text = bindType
						end)
						y = y + 26
						row("Value")
						local valBtn = Instance.new("TextButton", panel)
						valBtn.Size = UDim2.new(0, 36, 0, 18)
						valBtn.Position = UDim2.new(0.45, 0, 0, y)
						valBtn.BackgroundColor3 = THEME.panelHighlight
						Instance.new("UICorner", valBtn).CornerRadius = UDim.new(1, 0)
						local valThumb = Instance.new("Frame", valBtn)
						valThumb.Size = UDim2.fromOffset(14, 14)
						valThumb.AnchorPoint = Vector2.new(0.5, 0.5)
						valThumb.Position = toggled and UDim2.new(1, -9, 0.5, 0) or UDim2.new(0, 9, 0.5, 0)
						valThumb.BackgroundColor3 = THEME.textActive
						Instance.new("UICorner", valThumb).CornerRadius = UDim.new(1, 0)
						local function setVal(v)
							UpdateToggle(v, false)
							TweenService:Create(valThumb, TweenInfo.new(0.2), { Position = v and UDim2.new(1, -9, 0.5, 0) or UDim2.new(0, 9, 0.5, 0) }):Play()
						end
						valBtn.Activated:Connect(function() setVal(not toggled) end)
						activeBindEditor = panel
					end

					local function openContext()
						if activeContext then activeContext:Destroy(); activeContext=nil end
						local menu = Instance.new("Frame", rootFrame)
						menu.ZIndex = 12
						menu.BackgroundColor3 = THEME.panel
						menu.Size = UDim2.fromOffset(170, 160)
						menu.BackgroundTransparency = 0
						local pos = holderToggle.AbsolutePosition
						menu.Position = UDim2.fromOffset(pos.X + 10, pos.Y + 24)
						Instance.new("UICorner", menu).CornerRadius = UDim.new(0, 8)
						local mStroke2 = Instance.new("UIStroke", menu)
						mStroke2.Color = THEME.separator
						mStroke2.Transparency = 0.9
						mStroke2.Thickness = 1
						local layout = Instance.new("UIListLayout", menu)
						layout.Padding = UDim.new(0, 2)
						local pad = Instance.new("UIPadding", menu)
						pad.PaddingTop = UDim.new(0, 6); pad.PaddingBottom = UDim.new(0, 6); pad.PaddingLeft = UDim.new(0, 8); pad.PaddingRight = UDim.new(0, 8)
						local function addItem(text, action, isDanger)
							local b = Instance.new("TextButton", menu)
							b.Size = UDim2.new(1, 0, 0, 28)
							b.BackgroundColor3 = THEME.panel
							b.BackgroundTransparency = 1
							b.Text = ""
							Instance.new("UICorner", b).CornerRadius = UDim.new(0, 6)
							local l = Instance.new("TextLabel", b)
							l.Size = UDim2.new(1, -10, 1, 0)
							l.Position = UDim2.fromOffset(6, 0)
							l.BackgroundTransparency = 1
							l.Font = Enum.Font.GothamSemibold
							l.Text = text
							l.TextXAlignment = Enum.TextXAlignment.Left
							l.TextColor3 = isDanger and Color3.fromRGB(235,87,87) or THEME.text
							l.TextSize = 13
							b.MouseEnter:Connect(function() TweenService:Create(b, TweenInfo.new(0.15), { BackgroundTransparency = 0.2, BackgroundColor3 = THEME.panelHighlight }):Play() end)
							b.MouseLeave:Connect(function() TweenService:Create(b, TweenInfo.new(0.15), { BackgroundTransparency = 1, BackgroundColor3 = THEME.panel }):Play() end)
							if action then b.Activated:Connect(action) end
							return b
						end
						local header = Instance.new("TextLabel", menu)
						header.Size = UDim2.new(1, 0, 0, 26)
						header.BackgroundTransparency = 1
						header.Font = Enum.Font.GothamBold
						header.Text = "Toggle \"" .. (titleToggle.Text or "-") .. "\""
						header.TextColor3 = THEME.text
						header.TextSize = 13
						header.TextXAlignment = Enum.TextXAlignment.Left
						addItem("New Bind", function()
							openBindEditor(menu.AbsolutePosition)
						end)
						addItem("Bind List", function() end)
						addItem("Copy Lua Path", function()
							local s = opts.SaveKey or (titleToggle.Text or "")
							if typeof(setclipboard) == "function" then pcall(setclipboard, s) end
						end)
						addItem("Reset", function()
							SetBindKey(nil)
						end, true)
						activeContext = menu
						clickToClose.Visible = true
					end
					menuBtn.Activated:Connect(openContext)
				end

				local toggleObject = {}
				toggleObject.Object = holderToggle
				toggleObject.GetState = function()
					return toggled
				end
				toggleObject.SetState = function(v)
					UpdateToggle(v, false) -- [[ Ð˜Ð—ÐœÐ•ÐÐ•ÐÐž ]] -- Ð£Ð±ÐµÐ¶Ð´Ð°ÐµÐ¼ÑÑ, Ñ‡Ñ‚Ð¾ isInstant = false, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Callback
				end
				toggleObject.Call = function(val)
					local v = (val ~= nil) and val or toggled
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(v) end
				end

				-- keybind helpers
				toggleObject.SetBindKey = function(kc)
					if not opts.Keybindable then return end
					SetBindKey(kc)
				end
				toggleObject.GetBindKey = function()
					return boundKC
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = toggleObject
				end
				return toggleObject
			end
            function Section:CreateKeybind(opts)
                opts = opts or {}
				local defaultKC = opts.Default or Library.Config.ToggleKey
				if opts.SaveKey then
					local saved = Library:_GetSetting(opts.SaveKey, nil)
					if saved then
						local kc = stringToKeycode(saved)
						if kc then defaultKC = kc end
					end
				end
				local holder = Instance.new("Frame", contentFrame)
				holder.Size = UDim2.new(1, 0, 0, 28)
				holder.BackgroundTransparency = 1
				local title = Instance.new("TextLabel", holder)
				title.Size = UDim2.new(1, -120, 1, 0)
				title.BackgroundTransparency = 1
                title.Font = Enum.Font.GothamSemibold
                title.Text = Library:_Translate(opts.Title or "Toggle Key")
                title.TextColor3 = THEME.text
                title.TextSize = 13
                title.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(title, opts.Title or "Toggle Key")
				local bindBtn = Instance.new("TextButton", holder)
				bindBtn.Size = UDim2.new(0, 110, 1, 0)
				bindBtn.Position = UDim2.new(1, 0, 0, 0)
				bindBtn.AnchorPoint = Vector2.new(1, 0)
				bindBtn.BackgroundColor3 = THEME.panelHighlight
				bindBtn.BackgroundTransparency = 0.5
				bindBtn.Text = keycodeToString(defaultKC)
				bindBtn.Font = Enum.Font.Gotham
				bindBtn.TextSize = 12
				bindBtn.TextColor3 = THEME.textDim
				Instance.new("UICorner", bindBtn).CornerRadius = UDim.new(0, 6)
				local stroke = Instance.new("UIStroke", bindBtn)
				stroke.Color = THEME.separator
				stroke.Transparency = 0.85
				stroke.Thickness = 1

				local currentKC = defaultKC
				local listenConn
				local listening = false
                local function setKey(kc, fromUser)
                    if not kc then return end
                    currentKC = kc
                    bindBtn.Text = keycodeToString(kc)
                    -- fit button width to text
                    local w = bindBtn.TextBounds.X
                    if w == 0 then w = 40 end
                    bindBtn.Size = UDim2.new(0, math.clamp(w + 16, 60, 200), 1, 0)
                    if opts.SetToggleKey ~= false then
                        Library.Config.ToggleKey = kc
                    end
                    if opts.Callback and not Library._suppressCallbacks then opts.Callback(kc) end
                    if opts.SaveKey then Library:_SaveSetting(opts.SaveKey, keycodeToString(kc)) end
                end

				bindBtn.Activated:Connect(function()
					if listening then return end
					listening = true
					Library._captureBlockInput = true
					bindBtn.Text = "Press a key..."
					listenConn = UserInputService.InputBegan:Connect(function(input, gp)
						if gp then return end
						if input.UserInputType == Enum.UserInputType.Keyboard then
							local kc = input.KeyCode
							if kc and kc ~= Enum.KeyCode.Unknown then
								setKey(kc, true)
								listening = false
								Library._captureBlockInput = false
								listenConn:Disconnect()
							end
						end
					end)
				end)

				-- apply default
				setKey(currentKC, false)

				local bindObj = {}
				bindObj.Object = bindBtn
				bindObj.GetKey = function()
					return currentKC
				end
				bindObj.SetKey = function(v)
					local kc = v
					if typeof(v) == "string" then kc = stringToKeycode(v) end
					if kc then setKey(kc, false) end
				end
				bindObj.Call = function(v)
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(v or currentKC) end
				end
				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = bindObj
				end
				return bindObj
			end
            function Section:CreateInputBox(opts)
                opts = opts or {}
				local holderInput = Instance.new("Frame", contentFrame)
				holderInput.Size = UDim2.new(1, 0, 0, 28)
				holderInput.BackgroundTransparency = 1
				local titleInput = Instance.new("TextLabel", holderInput)
				titleInput.Size = UDim2.new(0.5, -10, 1, 0)
				titleInput.BackgroundTransparency = 1
                titleInput.Font = Enum.Font.GothamSemibold
                titleInput.Text = Library:_Translate(opts.Title or "Input")
                titleInput.TextColor3 = THEME.text
                titleInput.TextSize = 13
                titleInput.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleInput, opts.Title or "Input")
                local inputBox = Instance.new("TextBox", holderInput)
                inputBox.AutomaticSize = Enum.AutomaticSize.X
                inputBox.Size = UDim2.new(0, 120, 1, 0)
                inputBox.Position = UDim2.new(0.5, 0, 0, 0)
                inputBox.BackgroundColor3 = THEME.panelHighlight
                inputBox.BackgroundTransparency = 0.5
                inputBox.Font = Enum.Font.Gotham
                inputBox.TextColor3 = THEME.text
                inputBox.TextSize = 13
                local _phRaw = opts.Placeholder or "Enter text..."
                inputBox.PlaceholderText = Library:_Translate(_phRaw)
                inputBox.PlaceholderColor3 = THEME.textDim
                inputBox.TextXAlignment = Enum.TextXAlignment.Left
                inputBox.ClearTextOnFocus = false
                Library:_BindLocalePlaceholder(inputBox, _phRaw)
                local textPaddingInput = Instance.new("UIPadding", inputBox)
                textPaddingInput.PaddingLeft = UDim.new(0, 8)
                textPaddingInput.PaddingRight = UDim.new(0, 8)
                local cornerInput = Instance.new("UICorner", inputBox)
                cornerInput.CornerRadius = UDim.new(0, 6)
                local strokeInput = Instance.new("UIStroke", inputBox)
                strokeInput.Color = THEME.separator
                strokeInput.Transparency = 0.8
                strokeInput.Thickness = 1
                local function adjustWidth()
                    local w = inputBox.TextBounds.X
                    if w == 0 then w = 40 end
                    local newSize = UDim2.new(0, math.clamp(w + 16, 80, math.floor(holderInput.AbsoluteSize.X * 0.48)), 1, 0)
                    TweenService:Create(inputBox, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Size = newSize }):Play()
                end
                inputBox.Focused:Connect(function()
                    TweenService:Create(strokeInput, TweenInfo.new(0.2), { Color = THEME.accent, Transparency = 0.4 }):Play()
                end)
                inputBox.FocusLost:Connect(function(enterPressed)
                    TweenService:Create(strokeInput, TweenInfo.new(0.2), { Color = THEME.separator, Transparency = 0.8 }):Play()
                    if enterPressed and opts.Callback and not Library._suppressCallbacks then
                        opts.Callback(inputBox.Text)
                    end
                    if opts.SaveKey and enterPressed then
                        Library:_SaveSetting(opts.SaveKey, inputBox.Text)
                    end
                    adjustWidth()
                end)
                inputBox:GetPropertyChangedSignal("Text"):Connect(adjustWidth)
				if opts.SaveKey then
					local savedVal = Library:_GetSetting(opts.SaveKey, nil)
					if savedVal ~= nil then
						inputBox.Text = tostring(savedVal)
					end
				end

				local inputObject = {}
				inputObject.Object = inputBox
				inputObject.GetText = function()
					return inputBox.Text
				end
				inputObject.SetText = function(v)
					local text = tostring(v)
					inputBox.Text = text
					if opts.Callback and not Library._suppressCallbacks then -- callback
						opts.Callback(text)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, text)
					end
				end
				inputObject.Call = function(val)
					local v = val or inputBox.Text
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(v) end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = inputObject
				end
				return inputObject
			end

			local function openDropdown(dropdownButton, createItemsFunc)
				if activeDropdown == dropdownButton then
					closeActiveDropdown()
					return
				end
				if activeDropdown then
					closeActiveDropdown()
				end
				for _, child in ipairs(dropdownHost:GetChildren()) do
					if child:IsA("GuiObject")
						and not child:IsA("UILayout")
						and not child:IsA("UIPadding")
						and not child:IsA("UIStroke")
						and not child:IsA("UICorner") then
						child:Destroy()
					end
				end
				activeDropdown = dropdownButton
				clickToClose.Visible = true
				createItemsFunc()
				local openPos = UDim2.new(1, -dropdownHost.AbsoluteSize.X - 8, 0, headerHeight + 8)
				TweenService:Create(dropdownHost, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = openPos }):Play()
			end
            function Section:CreateDropdown(opts)
                opts = opts or {}
				local items = opts.Items or {}
				local defaultIndex = opts.Default or 1
				local currentSelection = items[defaultIndex]
				if opts.SaveKey then
					local saved = Library:_GetSetting(opts.SaveKey, nil)
					if saved ~= nil then
						currentSelection = saved
					end
				end
				local holderDrop = Instance.new("Frame", contentFrame)
				holderDrop.Size = UDim2.new(1, 0, 0, 28)
				holderDrop.BackgroundTransparency = 1
                local titleDrop = Instance.new("TextLabel", holderDrop)
                titleDrop.Size = UDim2.new(0.5, -10, 1, 0)
                titleDrop.BackgroundTransparency = 1
                titleDrop.Font = Enum.Font.GothamSemibold
                titleDrop.Text = Library:_Translate(opts.Title or "Dropdown")
                titleDrop.TextColor3 = THEME.text
                titleDrop.TextSize = 13
                titleDrop.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleDrop, opts.Title or "Dropdown")
				local dropdownButton = Instance.new("TextButton", holderDrop)
				dropdownButton.Size = UDim2.new(0.5, 0, 1, 0)
				dropdownButton.Position = UDim2.new(0.5, 0, 0, 0)
				dropdownButton.BackgroundColor3 = THEME.panelHighlight
				dropdownButton.BackgroundTransparency = 0.5
				dropdownButton.Text = ""
				Instance.new("UICorner", dropdownButton).CornerRadius = UDim.new(0, 6)
				Instance.new("UIStroke", dropdownButton).Color = THEME.separator
                local selectedLabel = Instance.new("TextLabel", dropdownButton)
                selectedLabel.Size = UDim2.new(1, -8, 1, 0)
                selectedLabel.Position = UDim2.fromOffset(8, 0)
                selectedLabel.BackgroundTransparency = 1
                selectedLabel.Font = Enum.Font.Gotham
                selectedLabel.Text = Library:_Translate(currentSelection)
                selectedLabel.TextColor3 = THEME.textDim
                selectedLabel.TextSize = 13
                selectedLabel.TextXAlignment = Enum.TextXAlignment.Left
                selectedLabel.TextWrapped = false
                selectedLabel.TextTruncate = Enum.TextTruncate.AtEnd
                local function _refreshSelectedText()
                    selectedLabel.Text = Library:_Translate(currentSelection)
                end
                Library:_onLanguageChanged(_refreshSelectedText)
				dropdownButton.Activated:Connect(function()
					openDropdown(dropdownButton, function()
						if opts.Searchable then
                            local searchBox = Instance.new("TextBox", dropdownHost)
                            searchBox.Size = UDim2.new(1, 0, 0, 28)
                            searchBox.BackgroundColor3 = THEME.panelHighlight
                            searchBox.BackgroundTransparency = 0
                            searchBox.Font = Enum.Font.Gotham
                            searchBox.TextColor3 = THEME.text
                            searchBox.TextSize = 13
                            searchBox.PlaceholderText = Library:_Translate("Search...")
                            searchBox.PlaceholderColor3 = THEME.textDim
                            searchBox.Text = ""
                            searchBox.TextXAlignment = Enum.TextXAlignment.Left
                            searchBox.ClearTextOnFocus = false
							local searchPadding = Instance.new("UIPadding", searchBox)
							searchPadding.PaddingLeft = UDim.new(0, 8)
							Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0, 6)
							local searchStroke = Instance.new("UIStroke", searchBox)
							searchStroke.Color = THEME.separator
							searchStroke.Transparency = 0.8
							searchStroke.Thickness = 1
							local function buildOptions(filter)
								for _, child in ipairs(dropdownHost:GetChildren()) do
									if child:IsA("TextButton") then
										child:Destroy()
									end
								end
								local seenItems = {}
								for _, item in ipairs(items) do
									if ((filter == nil or filter == "") or string.find(string.lower(item), string.lower(filter), 1, true)) and not seenItems[item] then
										seenItems[item] = true
                                        local optionBtn = Instance.new("TextButton", dropdownHost)
                                        optionBtn.Size = UDim2.new(1, 0, 0, 32)
                                        optionBtn.BackgroundColor3 = THEME.panel
                                        optionBtn.BackgroundTransparency = 1
                                        optionBtn.Text = ""
                                        optionBtn:SetAttribute("rawItem", item)
                                        Instance.new("UICorner", optionBtn).CornerRadius = UDim.new(0, 6)
                                        -- blue marker for current selection
                                        local marker = Instance.new("Frame", optionBtn)
                                        marker.Size = UDim2.fromOffset(2, 18)
                                        marker.Position = UDim2.new(0, 3, 0.5, 0)
                                        marker.AnchorPoint = Vector2.new(0, 0.5)
                                        marker.BackgroundColor3 = THEME.accent
                                        marker.BorderSizePixel = 0
                                        Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
                                        Library:_RegisterAccent(marker, "BackgroundColor3")
                                        Library:_RegisterAccent(marker, "BackgroundColor3")
                                        local optionLabel = Instance.new("TextLabel", optionBtn)
                                        optionLabel.Size = UDim2.new(1, -16, 1, 0)
                                        optionLabel.Position = UDim2.fromOffset(8, 0)
                                        optionLabel.BackgroundTransparency = 1
                                        optionLabel.Font = Enum.Font.GothamSemibold
                                        optionLabel.Text = Library:_Translate(item)
                                        optionLabel.TextColor3 = THEME.text
                                        optionLabel.TextSize = 13
                                        optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabel.TextWrapped = false
                                        optionLabel.TextTruncate = Enum.TextTruncate.AtEnd
											marker.Visible = (item == currentSelection)
										optionBtn.MouseEnter:Connect(function()
											TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panelHighlight, BackgroundTransparency = 0.5 }):Play()
										end)
										optionBtn.MouseLeave:Connect(function()
											TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panel, BackgroundTransparency = 1 }):Play()
										end)
										optionBtn.Activated:Connect(function()
                                            currentSelection = item
                                            _refreshSelectedText()
                                            -- update markers visibility
                                            for _, c in ipairs(dropdownHost:GetChildren()) do
                                                if c:IsA("TextButton") then
                                                    local m = nil
                                                    for _, cc in ipairs(c:GetChildren()) do
                                                        if cc:IsA("Frame") then m = cc break end
                                                    end
                                                    local raw = c:GetAttribute("rawItem")
                                                    if m then m.Visible = (raw == currentSelection) end
                                                end
                                            end
                                            if opts.Callback and not Library._suppressCallbacks then opts.Callback(item)
                                            end
											if opts.SaveKey then
												Library:_SaveSetting(opts.SaveKey, item)
											end
											closeActiveDropdown()
										end)
									end
								end
							end
							buildOptions("")
							searchBox:GetPropertyChangedSignal("Text"):Connect(function()
								buildOptions(searchBox.Text)
							end)
						else
                            local seenItems = {}
                            for _, item in ipairs(items) do
                                if not seenItems[item] then
                                    seenItems[item] = true
                                        local optionBtn = Instance.new("TextButton", dropdownHost)
                                        optionBtn.Size = UDim2.new(1, 0, 0, 32)
                                        optionBtn.BackgroundColor3 = THEME.panel
                                        optionBtn.BackgroundTransparency = 1
                                        optionBtn.Text = ""
                                        optionBtn:SetAttribute("rawItem", item)
                                        Instance.new("UICorner", optionBtn).CornerRadius = UDim.new(0, 6)
                                        local marker = Instance.new("Frame", optionBtn)
                                        marker.Size = UDim2.fromOffset(2, 18)
                                        marker.Position = UDim2.new(0, 3, 0.5, 0)
                                        marker.AnchorPoint = Vector2.new(0, 0.5)
										marker.BackgroundColor3 = THEME.accent
										marker.BorderSizePixel = 0
										Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
                                        local optionLabel = Instance.new("TextLabel", optionBtn)
                                        optionLabel.Size = UDim2.new(1, -16, 1, 0)
                                        optionLabel.Position = UDim2.fromOffset(8, 0)
                                        optionLabel.BackgroundTransparency = 1
                                        optionLabel.Font = Enum.Font.GothamSemibold
                                        optionLabel.Text = Library:_Translate(item)
                                        optionLabel.TextColor3 = THEME.text
                                        optionLabel.TextSize = 13
                                        optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabel.TextWrapped = false
                                        optionLabel.TextTruncate = Enum.TextTruncate.AtEnd
										marker.Visible = (item == currentSelection)
									optionBtn.MouseEnter:Connect(function()
										TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panelHighlight, BackgroundTransparency = 0.5 }):Play()
									end)
									optionBtn.MouseLeave:Connect(function()
										TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panel, BackgroundTransparency = 1 }):Play()
									end)
                                    optionBtn.Activated:Connect(function()
                                        currentSelection = item
                                        _refreshSelectedText()
                                        -- update markers visibility
                                        for _, c in ipairs(dropdownHost:GetChildren()) do
                                            if c:IsA("TextButton") then
                                                local m
                                                for _, cc in ipairs(c:GetChildren()) do
                                                    if cc:IsA("Frame") then m = cc break end
                                                end
                                                local raw = c:GetAttribute("rawItem")
                                                if m then m.Visible = (raw == currentSelection) end
                                            end
                                        end
                                        if opts.Callback and not Library._suppressCallbacks then opts.Callback(item)
                                        end
										if opts.SaveKey then
											Library:_SaveSetting(opts.SaveKey, item)
										end
										closeActiveDropdown()
									end)
								end
							end
						end
					end)
				end)

				local dropdownObject = {}
				dropdownObject.Object = dropdownButton
				dropdownObject.GetSelection = function()
					return currentSelection
				end
                dropdownObject.SetSelection = function(val)
                    if not val then return end
                    if not table.find(items, val) then return end
                    currentSelection = val
                    selectedLabel.Text = Library:_Translate(val)
                    if opts.Callback and not Library._suppressCallbacks then opts.Callback(val) end
                    if opts.SaveKey then Library:_SaveSetting(opts.SaveKey, val) end
                end
				dropdownObject.Call = function(val)
					local v = val or currentSelection
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(v) end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = dropdownObject
				end
				return dropdownObject
			end
            function Section:CreateMultiSelectDropdown(opts)
                opts = opts or {}
				local items = opts.Items or {}
				local savedSelections = nil
				if opts.SaveKey then
					local saved = Library:_GetSetting(opts.SaveKey, nil)
					if typeof(saved) == "table" then
						savedSelections = saved
					end
				end
				local selections = {}
				local selectionCount = 0
				local holderMulti = Instance.new("Frame", contentFrame)
				holderMulti.Size = UDim2.new(1, 0, 0, 28)
				holderMulti.BackgroundTransparency = 1
                local titleMulti = Instance.new("TextLabel", holderMulti)
                titleMulti.Size = UDim2.new(0.5, -10, 1, 0)
                titleMulti.BackgroundTransparency = 1
                titleMulti.Font = Enum.Font.GothamSemibold
                titleMulti.Text = Library:_Translate(opts.Title or "Multi-Select")
                titleMulti.TextColor3 = THEME.text
                titleMulti.TextSize = 13
                titleMulti.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleMulti, opts.Title or "Multi-Select")
				local dropdownButton = Instance.new("TextButton", holderMulti)
				dropdownButton.Size = UDim2.new(0.5, 0, 1, 0)
				dropdownButton.Position = UDim2.new(0.5, 0, 0, 0)
				dropdownButton.BackgroundColor3 = THEME.panelHighlight
				dropdownButton.BackgroundTransparency = 0.5
				dropdownButton.Text = ""
				Instance.new("UICorner", dropdownButton).CornerRadius = UDim.new(0, 6)
				Instance.new("UIStroke", dropdownButton).Color = THEME.separator
				local selectedLabel = Instance.new("TextLabel", dropdownButton)
				selectedLabel.Size = UDim2.new(1, -8, 1, 0)
				selectedLabel.Position = UDim2.fromOffset(8, 0)
				selectedLabel.BackgroundTransparency = 1
				selectedLabel.Font = Enum.Font.Gotham
				selectedLabel.TextColor3 = THEME.textDim
				selectedLabel.TextSize = 13
				selectedLabel.TextXAlignment = Enum.TextXAlignment.Left

				local function updateSelectionLabel()
					selectedLabel.Text = selectionCount .. " / " .. #items .. " Selected"
				end
				
				local function getSelectedItemsAsTable()
					local result = {}
					for item, isSelected in pairs(selections) do
						if isSelected then
							table.insert(result, item)
						end
					end
					return result
				end

				for _, item in ipairs(items) do
					local isSelected = false
					if savedSelections and savedSelections[item] ~= nil then
						isSelected = savedSelections[item]
					end
					selections[item] = isSelected
					if isSelected then
						selectionCount = selectionCount + 1
					end
				end
				updateSelectionLabel()
				dropdownButton.Activated:Connect(function()
					openDropdown(dropdownButton, function()
						if opts.Searchable then
                            local searchBox = Instance.new("TextBox", dropdownHost)
                            searchBox.Size = UDim2.new(1, 0, 0, 28)
                            searchBox.BackgroundColor3 = THEME.panelHighlight
                            searchBox.BackgroundTransparency = 0
                            searchBox.Font = Enum.Font.Gotham
                            searchBox.TextColor3 = THEME.text
                            searchBox.TextSize = 13
                            searchBox.PlaceholderText = Library:_Translate("Search...")
                            searchBox.PlaceholderColor3 = THEME.textDim
                            searchBox.Text = ""
                            searchBox.TextXAlignment = Enum.TextXAlignment.Left
                            searchBox.ClearTextOnFocus = false
							local searchPadding = Instance.new("UIPadding", searchBox)
							searchPadding.PaddingLeft = UDim.new(0, 8)
							Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0, 6)
							local searchStroke = Instance.new("UIStroke", searchBox)
							searchStroke.Color = THEME.separator
							searchStroke.Transparency = 0.8
							searchStroke.Thickness = 1
							local function buildOptions(filter)
								for _, child in ipairs(dropdownHost:GetChildren()) do
									if child:IsA("TextButton") then
										child:Destroy()
									end
								end
								local seen = {}
								for _, item in ipairs(items) do
									if ((filter == nil or filter == "") or string.find(string.lower(item), string.lower(filter), 1, true)) and not seen[item] then
										seen[item] = true
											local optionBtn = Instance.new("TextButton", dropdownHost)
											optionBtn.Size = UDim2.new(1, 0, 0, 32)
											optionBtn.BackgroundTransparency = 1
											optionBtn.Text = ""
											local marker = Instance.new("Frame", optionBtn)
											marker.Size = UDim2.fromOffset(2, 18)
											marker.Position = UDim2.new(0, 3, 0.5, 0)
											marker.AnchorPoint = Vector2.new(0, 0.5)
											marker.BackgroundColor3 = THEME.accent
											marker.BorderSizePixel = 0
											Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
										local boxMulti = Instance.new("Frame", optionBtn)
										boxMulti.Size = UDim2.fromOffset(18, 18)
										boxMulti.Position = UDim2.new(1, -8, 0.5, 0)
										boxMulti.AnchorPoint = Vector2.new(1, 0.5)
										boxMulti.BackgroundColor3 = THEME.accent
										Instance.new("UICorner", boxMulti).CornerRadius = UDim.new(0, 4)
										Library:_RegisterAccent(boxMulti, "BackgroundColor3")
										local strokeMulti = Instance.new("UIStroke", boxMulti)
										strokeMulti.Color = THEME.separator
										strokeMulti.Transparency = 0.8
										strokeMulti.Thickness = 0.5
										local checkmarkMulti = Instance.new("ImageLabel", boxMulti)
										checkmarkMulti.Size = UDim2.new(1, -4, 1, -4)
										checkmarkMulti.Position = UDim2.new(0.5, 0, 0.5, 0)
										checkmarkMulti.AnchorPoint = Vector2.new(0.5, 0.5)
										checkmarkMulti.BackgroundTransparency = 1
										checkmarkMulti.Image = "rbxassetid://101733655234124"
										checkmarkMulti.ImageColor3 = THEME.textActive
                                        local optionLabelMulti = Instance.new("TextLabel", optionBtn)
                                        optionLabelMulti.Size = UDim2.new(1, -44, 1, 0)
                                        optionLabelMulti.Position = UDim2.fromOffset(8, 0)
                                        optionLabelMulti.BackgroundTransparency = 1
                                        optionLabelMulti.Font = Enum.Font.Gotham
                                        optionLabelMulti.Text = item
                                        optionLabelMulti.TextColor3 = THEME.text
                                        optionLabelMulti.TextSize = 13
                                        optionLabelMulti.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabelMulti.TextWrapped = false
                                        optionLabelMulti.TextTruncate = Enum.TextTruncate.AtEnd
											local function updateVisual(isInstant)
												local checked = selections[item]
												local tweenInfo = isInstant and TweenInfo.new(0) or TweenInfo.new(0.2)
												TweenService:Create(boxMulti, tweenInfo, { BackgroundTransparency = checked and 0 or 1 }):Play()
												TweenService:Create(checkmarkMulti, tweenInfo, { ImageTransparency = checked and 0 or 1 }):Play()
												-- indicator disabled for multi-select
												-- keep marker hidden regardless of selection
												-- marker may be nil in some branches
												if marker then marker.Visible = false end
											end
										updateVisual(true)
										optionBtn.Activated:Connect(function()
											selections[item] = not selections[item]
											if selections[item] then selectionCount += 1 else selectionCount -= 1 end
											updateVisual(false)
											updateSelectionLabel()
											if opts.Callback and not Library._suppressCallbacks then opts.Callback(getSelectedItemsAsTable())
											end
											if opts.SaveKey then
												Library:_SaveSetting(opts.SaveKey, selections)
											end
										end)
									end
								end
							end
							buildOptions("")
							searchBox:GetPropertyChangedSignal("Text"):Connect(function()
								buildOptions(searchBox.Text)
							end)
						else
							local seen = {}
							for _, item in ipairs(items) do
								if not seen[item] then
									seen[item] = true
                    local optionBtn = Instance.new("TextButton", dropdownHost)
                    optionBtn.Size = UDim2.new(1, 0, 0, 32)
                    optionBtn.BackgroundTransparency = 1
                    optionBtn.Text = ""
                    -- blue marker for selected items
                    local marker = Instance.new("Frame", optionBtn)
                    marker.Size = UDim2.fromOffset(2, 18)
                    marker.Position = UDim2.new(0, 3, 0.5, 0)
                    marker.AnchorPoint = Vector2.new(0, 0.5)
                    marker.BackgroundColor3 = THEME.accent
                    marker.BorderSizePixel = 0
                    Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
                    Library:_RegisterAccent(marker, "BackgroundColor3")
                    Library:_RegisterAccent(marker, "BackgroundColor3")
                    local boxMulti = Instance.new("Frame", optionBtn)
									boxMulti.Size = UDim2.fromOffset(18, 18)
									boxMulti.Position = UDim2.new(1, -8, 0.5, 0)
									boxMulti.AnchorPoint = Vector2.new(1, 0.5)
									boxMulti.BackgroundColor3 = THEME.accent
									Instance.new("UICorner", boxMulti).CornerRadius = UDim.new(0, 4)
									Library:_RegisterAccent(boxMulti, "BackgroundColor3")
									local strokeMulti = Instance.new("UIStroke", boxMulti)
									strokeMulti.Color = THEME.separator
									strokeMulti.Transparency = 0.8
									strokeMulti.Thickness = 0.5
									local checkmarkMulti = Instance.new("ImageLabel", boxMulti)
									checkmarkMulti.Size = UDim2.new(1, -4, 1, -4)
									checkmarkMulti.Position = UDim2.new(0.5, 0, 0.5, 0)
									checkmarkMulti.AnchorPoint = Vector2.new(0.5, 0.5)
									checkmarkMulti.BackgroundTransparency = 1
									checkmarkMulti.Image = "rbxassetid://101733655234124"
									checkmarkMulti.ImageColor3 = THEME.textActive
                                        local optionLabelMulti = Instance.new("TextLabel", optionBtn)
                                        optionLabelMulti.Size = UDim2.new(1, -44, 1, 0)
                                        optionLabelMulti.Position = UDim2.fromOffset(8, 0)
                                        optionLabelMulti.BackgroundTransparency = 1
                                        optionLabelMulti.Font = Enum.Font.Gotham
                                        optionLabelMulti.Text = item
                                        optionLabelMulti.TextColor3 = THEME.text
                                        optionLabelMulti.TextSize = 13
                                        optionLabelMulti.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabelMulti.TextWrapped = false
                                        optionLabelMulti.TextTruncate = Enum.TextTruncate.AtEnd
                                    local function updateVisual(isInstant)
                                        local checked = selections[item]
                                        local tweenInfo = isInstant and TweenInfo.new(0) or TweenInfo.new(0.2)
                                        TweenService:Create(boxMulti, tweenInfo, { BackgroundTransparency = checked and 0 or 1 }):Play()
                                        TweenService:Create(checkmarkMulti, tweenInfo, { ImageTransparency = checked and 0 or 1 }):Play()
                                        -- indicator disabled for multi-select
                                        if marker then marker.Visible = false end
                                    end
									updateVisual(true)
									optionBtn.Activated:Connect(function()
										selections[item] = not selections[item]
										if selections[item] then selectionCount += 1 else selectionCount -= 1 end
										updateVisual(false)
										updateSelectionLabel()
										if opts.Callback and not Library._suppressCallbacks then opts.Callback(getSelectedItemsAsTable())
										end
										if opts.SaveKey then
											Library:_SaveSetting(opts.SaveKey, selections)
										end
									end)
								end
							end
						end
					end)
				end)
				
				local multiObject = {}
				multiObject.Object = dropdownButton
				multiObject.GetSelections = function()
					return selections
				end
				multiObject.GetSelectedItems = function()
					return getSelectedItemsAsTable()
				end
				multiObject.SetSelection = function(values)
                    selections = values

                    selectionCount = 0
                    for i,v in values do
                        if not v then continue end

                        selectionCount += 1
                    end

					updateSelectionLabel()
					if opts.SaveKey then Library:_SaveSetting(opts.SaveKey, selections) end
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(getSelectedItemsAsTable()) end
				end
				multiObject.Call = function()
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(getSelectedItemsAsTable())
					end
				end
				
				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = multiObject
				end
				return multiObject
			end
            function Section:CreateButton(opts)
                opts = opts or {}
                local callback = opts.Callback or function() end
                local buttonBtn = Instance.new("TextButton", contentFrame)
                buttonBtn.Size = UDim2.new(1, 0, 0, 32)
                buttonBtn.BackgroundColor3 = THEME.panelHighlight
                buttonBtn.BackgroundTransparency = 0.8
                buttonBtn.Font = Enum.Font.GothamBold
                buttonBtn.Text = Library:_Translate(opts.Title or "Button")
                buttonBtn.TextColor3 = THEME.text
                buttonBtn.TextSize = 13
                Library:_BindLocaleText(buttonBtn, opts.Title or "Button")
				Instance.new("UICorner", buttonBtn).CornerRadius = UDim.new(0, 6)
				local strokeBtn = Instance.new("UIStroke", buttonBtn)
				strokeBtn.Color = THEME.separator
				strokeBtn.Transparency = 0.8
				buttonBtn.MouseEnter:Connect(function()
					TweenService:Create(buttonBtn, TweenInfo.new(0.2), { BackgroundTransparency = 0.65 }):Play()
				end)
				buttonBtn.MouseLeave:Connect(function()
					TweenService:Create(buttonBtn, TweenInfo.new(0.2), { BackgroundTransparency = 0.8 }):Play()
				end)
				buttonBtn.Activated:Connect(callback)

				local buttonObject = {}
				buttonObject.Object = buttonBtn
				buttonObject.Fire = function()
					callback()
				end
				buttonObject.Call = function()
					callback()
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = buttonObject
				end
				return buttonObject
			end
            function Section:CreateSliderButtonDropdown(opts)
                opts = opts or {}
				local items = opts.Items or {}
				local defaultItem = opts.DefaultItem or 1
				local sliderMin = opts.Min or 0
				local sliderMax = opts.Max or 100
				local sliderDefault = opts.Default or sliderMin
				local decimals = opts.Decimals or 0
				local savedState = nil
				if opts.SaveKey then
					local saved = Library:_GetSetting(opts.SaveKey, nil)
					if typeof(saved) == "table" then
						savedState = saved
					end
				end
				local currentSelection = items[defaultItem]
				if savedState and savedState.item then
					currentSelection = savedState.item
				end
				local dropdownRow = Instance.new("Frame", contentFrame)
				dropdownRow.Size = UDim2.new(1, 0, 0, 28)
				dropdownRow.BackgroundTransparency = 1
                local dropdownTitleLabel = Instance.new("TextLabel", dropdownRow)
                dropdownTitleLabel.Size = UDim2.new(0.5, -10, 1, 0)
                dropdownTitleLabel.BackgroundTransparency = 1
                dropdownTitleLabel.Font = Enum.Font.GothamSemibold
                dropdownTitleLabel.Text = Library:_Translate(opts.DropdownTitle or (opts.Title or "Select"))
                dropdownTitleLabel.TextColor3 = THEME.text
                dropdownTitleLabel.TextSize = 13
                dropdownTitleLabel.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(dropdownTitleLabel, opts.DropdownTitle or (opts.Title or "Select"))
				local dropdownButton = Instance.new("TextButton", dropdownRow)
				dropdownButton.Size = UDim2.new(0.5, 0, 1, 0)
				dropdownButton.Position = UDim2.new(0.5, 0, 0, 0)
				dropdownButton.BackgroundColor3 = THEME.panelHighlight
				dropdownButton.BackgroundTransparency = 0.5
				dropdownButton.Text = ""
				Instance.new("UICorner", dropdownButton).CornerRadius = UDim.new(0, 6)
				Instance.new("UIStroke", dropdownButton).Color = THEME.separator
                local selectedLabel = Instance.new("TextLabel", dropdownButton)
                selectedLabel.Size = UDim2.new(1, -8, 1, 0)
                selectedLabel.Position = UDim2.fromOffset(8, 0)
                selectedLabel.BackgroundTransparency = 1
                selectedLabel.Font = Enum.Font.Gotham
                selectedLabel.Text = Library:_Translate(currentSelection or "")
                selectedLabel.TextColor3 = THEME.textDim
                selectedLabel.TextSize = 13
                selectedLabel.TextXAlignment = Enum.TextXAlignment.Left
                selectedLabel.TextWrapped = false
                selectedLabel.TextTruncate = Enum.TextTruncate.AtEnd
                local function _sbdRefreshSelectedText()
                    selectedLabel.Text = Library:_Translate(currentSelection or "")
                end
                Library:_onLanguageChanged(_sbdRefreshSelectedText)
				dropdownButton.Activated:Connect(function()
					openDropdown(dropdownButton, function()
						if opts.Searchable then
                            local searchBox = Instance.new("TextBox", dropdownHost)
                            searchBox.Size = UDim2.new(1, 0, 0, 28)
                            searchBox.BackgroundColor3 = THEME.panelHighlight
                            searchBox.BackgroundTransparency = 0
                            searchBox.Font = Enum.Font.Gotham
                            searchBox.TextColor3 = THEME.text
                            searchBox.TextSize = 13
                            searchBox.PlaceholderText = Library:_Translate("Search...")
                            searchBox.PlaceholderColor3 = THEME.textDim
                            searchBox.Text = ""
                            searchBox.TextXAlignment = Enum.TextXAlignment.Left
                            searchBox.ClearTextOnFocus = false
							local searchPadding = Instance.new("UIPadding", searchBox)
							searchPadding.PaddingLeft = UDim.new(0, 8)
							Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0, 6)
							local searchStroke = Instance.new("UIStroke", searchBox)
							searchStroke.Color = THEME.separator
							searchStroke.Transparency = 0.8
							searchStroke.Thickness = 1
							local function buildOptions(filter)
								for _, child in ipairs(dropdownHost:GetChildren()) do
									if child:IsA("TextButton") then
										child:Destroy()
									end
								end
								local seen = {}
								for _, item in ipairs(items) do
									if ((filter == nil or filter == "") or string.find(string.lower(item), string.lower(filter), 1, true)) and not seen[item] then
										seen[item] = true
                                        local optionBtn = Instance.new("TextButton", dropdownHost)
                                        optionBtn.Size = UDim2.new(1, 0, 0, 32)
                                        optionBtn.BackgroundTransparency = 1
                                        optionBtn.Text = ""
                                        optionBtn:SetAttribute("rawItem", item)
                                        local marker = Instance.new("Frame", optionBtn)
                                        marker.Size = UDim2.fromOffset(2, 18)
                                        marker.Position = UDim2.new(0, 3, 0.5, 0)
                                        marker.AnchorPoint = Vector2.new(0, 0.5)
                                        marker.BackgroundColor3 = THEME.accent
                                        marker.BorderSizePixel = 0
                                        Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
                                        local optionLabel = Instance.new("TextLabel", optionBtn)
                                        optionLabel.Size = UDim2.new(1, -16, 1, 0)
                                        optionLabel.Position = UDim2.fromOffset(8, 0)
                                        optionLabel.BackgroundTransparency = 1
                                        optionLabel.Font = Enum.Font.GothamSemibold
                                        optionLabel.Text = Library:_Translate(item)
                                        optionLabel.TextColor3 = THEME.text
                                        optionLabel.TextSize = 13
                                        optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabel.TextWrapped = false
                                        optionLabel.TextTruncate = Enum.TextTruncate.AtEnd
                                        marker.Visible = (item == currentSelection)
										optionBtn.MouseEnter:Connect(function()
											TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panelHighlight, BackgroundTransparency = 0.5 }):Play()
										end)
										optionBtn.MouseLeave:Connect(function()
											TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panel, BackgroundTransparency = 1 }):Play()
										end)
                                        optionBtn.Activated:Connect(function()
                                            currentSelection = item
                                            _sbdRefreshSelectedText()
                                            for _, c in ipairs(dropdownHost:GetChildren()) do
                                                if c:IsA("TextButton") then
                                                    local m = nil
                                                    for _, cc in ipairs(c:GetChildren()) do if cc:IsA("Frame") then m = cc break end end
                                                    local raw = c:GetAttribute("rawItem")
                                                    if m then m.Visible = (raw == currentSelection) end
                                                end
                                            end
                                            if opts.OnDropdownChange then
                                                opts.OnDropdownChange(item)
                                            end
											if opts.SaveKey then
												Library:_SaveSetting(opts.SaveKey, { item = currentSelection, value = currentValue })
											end
											closeActiveDropdown()
										end)
									end
								end
							end
							buildOptions("")
							searchBox:GetPropertyChangedSignal("Text"):Connect(function()
								buildOptions(searchBox.Text)
							end)
						else
							local seen = {}
							for _, item in ipairs(items) do
								if not seen[item] then
									seen[item] = true
                                    local optionBtn = Instance.new("TextButton", dropdownHost)
                                    optionBtn.Size = UDim2.new(1, 0, 0, 32)
                                    optionBtn.BackgroundTransparency = 1
                                        optionBtn.Text = ""
                                        optionBtn:SetAttribute("rawItem", item)
                                        local marker = Instance.new("Frame", optionBtn)
                                        marker.Size = UDim2.fromOffset(2, 18)
                                        marker.Position = UDim2.new(0, 3, 0.5, 0)
                                        marker.AnchorPoint = Vector2.new(0, 0.5)
                                        marker.BackgroundColor3 = THEME.accent
                                        marker.BorderSizePixel = 0
                                        Instance.new("UICorner", marker).CornerRadius = UDim.new(1, 0)
                                        local optionLabel = Instance.new("TextLabel", optionBtn)
                                        optionLabel.Size = UDim2.new(1, -16, 1, 0)
                                        optionLabel.Position = UDim2.fromOffset(8, 0)
                                        optionLabel.BackgroundTransparency = 1
                                        optionLabel.Font = Enum.Font.GothamSemibold
                                        optionLabel.Text = Library:_Translate(item)
                                        optionLabel.TextColor3 = THEME.text
                                        optionLabel.TextSize = 13
                                        optionLabel.TextXAlignment = Enum.TextXAlignment.Left
                                        optionLabel.TextWrapped = false
                                        optionLabel.TextTruncate = Enum.TextTruncate.AtEnd
                                        marker.Visible = (item == currentSelection)
									optionBtn.MouseEnter:Connect(function()
										TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panelHighlight, BackgroundTransparency = 0.5 }):Play()
									end)
									optionBtn.MouseLeave:Connect(function()
										TweenService:Create(optionBtn, TweenInfo.new(0.2), { BackgroundColor3 = THEME.panel, BackgroundTransparency = 1 }):Play()
									end)
                                    optionBtn.Activated:Connect(function()
                                        currentSelection = item
                                        _sbdRefreshSelectedText()
                                        for _, c in ipairs(dropdownHost:GetChildren()) do
                                            if c:IsA("TextButton") then
                                                local m = nil
                                                for _, cc in ipairs(c:GetChildren()) do if cc:IsA("Frame") then m = cc break end end
                                                local raw = c:GetAttribute("rawItem")
                                                if m then m.Visible = (raw == currentSelection) end
                                            end
                                        end
                                        if opts.OnDropdownChange then
                                            opts.OnDropdownChange(item)
                                        end
										if opts.SaveKey then
											Library:_SaveSetting(opts.SaveKey, { item = currentSelection, value = currentValue })
										end
										closeActiveDropdown()
									end)
								end
							end
						end
					end)
				end)
				if savedState and savedState.value ~= nil then
					local v = tonumber(savedState.value)
					if v and v >= sliderMin and v <= sliderMax then
						sliderDefault = v
					end
				end
				local holderRow = Instance.new("Frame", contentFrame)
				holderRow.Size = UDim2.new(1, 0, 0, 48)
				holderRow.BackgroundTransparency = 1
				local sliderPortion = opts.SliderPortion or 0.7
				local sliderHolder = Instance.new("Frame", holderRow)
				sliderHolder.Size = UDim2.new(sliderPortion, -4, 1, 0)
				sliderHolder.Position = UDim2.new(0, 0, 0, 0)
				sliderHolder.BackgroundTransparency = 1
				local topRow = Instance.new("Frame", sliderHolder)
				topRow.Size = UDim2.new(1, 0, 0, 18)
				topRow.BackgroundTransparency = 1
                local titleSlider = Instance.new("TextLabel", topRow)
                titleSlider.Size = UDim2.new(0.5, 0, 1, 0)
                titleSlider.BackgroundTransparency = 1
                titleSlider.Font = Enum.Font.GothamSemibold
                titleSlider.Text = Library:_Translate(opts.SliderTitle or "Quantity")
                titleSlider.TextColor3 = THEME.text
                titleSlider.TextSize = 13
                titleSlider.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleSlider, opts.SliderTitle or "Quantity")
				local valueLabel = Instance.new("TextLabel", topRow)
				valueLabel.Size = UDim2.new(0.5, 0, 1, 0)
				valueLabel.Position = UDim2.new(0.5, 0, 0, 0)
				valueLabel.BackgroundTransparency = 1
				valueLabel.Font = Enum.Font.Gotham
				valueLabel.TextColor3 = THEME.textDim
				valueLabel.TextSize = 13
				valueLabel.TextXAlignment = Enum.TextXAlignment.Right
				local track = Instance.new("Frame", sliderHolder)
				track.Size = UDim2.new(1, 0, 0, 6)
				track.Position = UDim2.new(0, 0, 0, 20)
				track.BackgroundColor3 = THEME.panelHighlight
				track.BorderSizePixel = 0
				Instance.new("UICorner", track).CornerRadius = UDim.new(1, 0)
				local fill = Instance.new("Frame", track)
				fill.BackgroundColor3 = THEME.accent
				fill.BorderSizePixel = 0
				Instance.new("UICorner", fill).CornerRadius = UDim.new(1, 0)
				local knob = Instance.new("ImageLabel", track)
				knob.Size = UDim2.fromOffset(14, 14)
				knob.AnchorPoint = Vector2.new(0.5, 0.5)
				knob.Position = UDim2.new(0, 0, 0.5, 0)
				knob.BackgroundTransparency = 1
				knob.Image = "rbxassetid://3570695787"
				knob.ImageColor3 = THEME.textActive
				local minVal, maxVal, defaultVal, dec = sliderMin, sliderMax, sliderDefault, decimals
				local currentValue, targetPercentage, currentPercentage = defaultVal, (defaultVal - minVal) / (maxVal - minVal), (defaultVal - minVal) / (maxVal - minVal)
				local draggingSlider = false
				local format = "%." .. dec .. "f"
				local function UpdateVisuals(percentage)
					local value = minVal + (maxVal - minVal) * percentage
					fill.Size = UDim2.new(percentage, 0, 1, 0)
					knob.Position = UDim2.new(percentage, 0, 0.5, 0)
					valueLabel.Text = string.format(format, value)
					currentValue = value
					if opts.OnSliderChange then
						opts.OnSliderChange(currentValue)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, { item = currentSelection, value = currentValue })
					end
				end
				RunService.Heartbeat:Connect(function()
					if currentPercentage ~= targetPercentage then
						currentPercentage = currentPercentage + (targetPercentage - currentPercentage) * 0.1
						if math.abs(currentPercentage - targetPercentage) < 0.001 then currentPercentage = targetPercentage end
						UpdateVisuals(currentPercentage)
					end
				end)
				track.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = true
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputChanged:Connect(function(input)
					if draggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = false
					end
				end)
				UpdateVisuals(currentPercentage)
				local buttonHolder = Instance.new("TextButton", holderRow)
				buttonHolder.Size = UDim2.new(1 - sliderPortion, 4, 1, 0)
				buttonHolder.Position = UDim2.new(sliderPortion, 4, 0, 0)
				buttonHolder.BackgroundColor3 = THEME.panelHighlight
				buttonHolder.BackgroundTransparency = 0.8
				buttonHolder.Font = Enum.Font.GothamBold
				buttonHolder.Text = opts.ButtonTitle or "Confirm"
				buttonHolder.TextColor3 = THEME.text
				buttonHolder.TextSize = 13
				Instance.new("UICorner", buttonHolder).CornerRadius = UDim.new(0, 6)
				local strokeBtn2 = Instance.new("UIStroke", buttonHolder)
				strokeBtn2.Color = THEME.separator
				strokeBtn2.Transparency = 0.8
				buttonHolder.MouseEnter:Connect(function()
					TweenService:Create(buttonHolder, TweenInfo.new(0.2), { BackgroundTransparency = 0.65 }):Play()
				end)
				buttonHolder.MouseLeave:Connect(function()
					TweenService:Create(buttonHolder, TweenInfo.new(0.2), { BackgroundTransparency = 0.8 }):Play()
				end)
				buttonHolder.Activated:Connect(function()
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(currentSelection, currentValue)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, { item = currentSelection, value = currentValue })
					end
				end)

				local sbdObject = {}
				sbdObject.Object = { Dropdown = dropdownButton, Slider = sliderHolder, ConfirmButton = buttonHolder }
				sbdObject.GetSelection = function()
					return currentSelection
				end
                sbdObject.SetSelection = function(val)
                    if val and table.find(items, val) then
                        currentSelection = val
                        selectedLabel.Text = Library:_Translate(val)
                        if opts.OnDropdownChange then opts.OnDropdownChange(val) end
                        if opts.SaveKey then
                            Library:_SaveSetting(opts.SaveKey, { item = currentSelection, value = currentValue })
                        end
                    end
                end
				sbdObject.GetValue = function()
					return currentValue
				end
				sbdObject.SetValue = function(v)
					v = math.clamp(v, minVal, maxVal)
					local percentage = (v - minVal) / (maxVal - minVal)
					targetPercentage = percentage
					currentPercentage = percentage -- ÐœÐ³Ð½Ð¾Ð²ÐµÐ½Ð½Ð¾Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ
					UpdateVisuals(percentage) -- [[ Ð˜Ð—ÐœÐ•ÐÐ•ÐÐž ]] -- Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ‹Ð·Ð¾Ð²ÐµÑ‚ OnSliderChange
				end
				sbdObject.Call = function(item, value)
					local sel = item or currentSelection
					local val = value or currentValue
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(sel, val) end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = sbdObject
				end
				return sbdObject
			end
            function Section:CreateSliderToggle(opts)
                opts = opts or {}
				local sliderMin = opts.Min or 0
				local sliderMax = opts.Max or 100
				local sliderDefault = opts.Default or sliderMin
				local decimals = opts.Decimals or 0
                local sliderTitle = Library:_Translate(opts.Title or "Value")
				local toggleDefault = opts.DefaultToggle or false
				local sliderPortion = opts.SliderPortion or 0.7
				if opts.SaveKey then
					local saved = Library:_GetSetting(opts.SaveKey, nil)
					if typeof(saved) == "table" then
						if saved.value ~= nil then
							local v = tonumber(saved.value)
							if v and v >= sliderMin and v <= sliderMax then
								sliderDefault = v
							end
						end
						if saved.toggled ~= nil then
							toggleDefault = saved.toggled and true or false
						end
					end
				end
				local rowFrame = Instance.new("Frame", contentFrame)
				rowFrame.Size = UDim2.new(1, 0, 0, 48)
				rowFrame.BackgroundTransparency = 1
				local sliderHolder = Instance.new("Frame", rowFrame)
				sliderHolder.Size = UDim2.new(sliderPortion, -4, 1, 0)
				sliderHolder.Position = UDim2.new(0, 0, 0, 0)
				sliderHolder.BackgroundTransparency = 1
				local topRow = Instance.new("Frame", sliderHolder)
				topRow.Size = UDim2.new(1, 0, 0, 18)
				topRow.BackgroundTransparency = 1
                local titleSlider = Instance.new("TextLabel", topRow)
                titleSlider.Size = UDim2.new(0.5, 0, 1, 0)
                titleSlider.BackgroundTransparency = 1
                titleSlider.Font = Enum.Font.GothamSemibold
                titleSlider.Text = sliderTitle
                titleSlider.TextColor3 = THEME.text
                titleSlider.TextSize = 13
                titleSlider.TextXAlignment = Enum.TextXAlignment.Left
                Library:_BindLocaleText(titleSlider, opts.Title or "Value")
				local valueLabel = Instance.new("TextLabel", topRow)
				valueLabel.Size = UDim2.new(0.5, 0, 1, 0)
				valueLabel.Position = UDim2.new(0.5, 0, 0, 0)
				valueLabel.BackgroundTransparency = 1
				valueLabel.Font = Enum.Font.Gotham
				valueLabel.TextColor3 = THEME.textDim
				valueLabel.TextSize = 13
				valueLabel.TextXAlignment = Enum.TextXAlignment.Right
				local track = Instance.new("Frame", sliderHolder)
				track.Size = UDim2.new(1, 0, 0, 6)
				track.Position = UDim2.new(0, 0, 0, 20)
				track.BackgroundColor3 = THEME.panelHighlight
				track.BorderSizePixel = 0
				Instance.new("UICorner", track).CornerRadius = UDim.new(1, 0)
				local fill = Instance.new("Frame", track)
				fill.BackgroundColor3 = THEME.accent
				fill.BorderSizePixel = 0
				Instance.new("UICorner", fill).CornerRadius = UDim.new(1, 0)
				local knob = Instance.new("ImageLabel", track)
				knob.Size = UDim2.fromOffset(14, 14)
				knob.AnchorPoint = Vector2.new(0.5, 0.5)
				knob.Position = UDim2.new(0, 0, 0.5, 0)
				knob.BackgroundTransparency = 1
				knob.Image = "rbxassetid://3570695787"
				knob.ImageColor3 = THEME.textActive
				local minVal, maxVal = sliderMin, sliderMax
				local currentValue = sliderDefault
				local targetPercentage = (sliderDefault - minVal) / (maxVal - minVal)
				local currentPercentage = targetPercentage
				local draggingSlider = false
				local format = "%." .. decimals .. "f"
				local toggledState = toggleDefault
				local function UpdateSliderVisuals(percentage)
					local value = minVal + (maxVal - minVal) * percentage
					fill.Size = UDim2.new(percentage, 0, 1, 0)
					knob.Position = UDim2.new(percentage, 0, 0.5, 0)
					valueLabel.Text = string.format(format, value)
					currentValue = value
					if opts.OnSliderChange then
						opts.OnSliderChange(value)
					end
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(currentValue, toggledState)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, { value = currentValue, toggled = toggledState })
					end
				end
				RunService.Heartbeat:Connect(function()
					if currentPercentage ~= targetPercentage then
						currentPercentage = currentPercentage + (targetPercentage - currentPercentage) * 0.1
						if math.abs(currentPercentage - targetPercentage) < 0.001 then currentPercentage = targetPercentage end
						UpdateSliderVisuals(currentPercentage)
					end
				end)
				track.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = true
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputChanged:Connect(function(input)
					if draggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
						targetPercentage = math.clamp((input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
					end
				end)
				UserInputService.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						draggingSlider = false
					end
				end)
				UpdateSliderVisuals(targetPercentage)
				local toggleHolder = Instance.new("TextButton", rowFrame)
				toggleHolder.Size = UDim2.new(1 - sliderPortion, 4, 1, 0)
				toggleHolder.Position = UDim2.new(sliderPortion, 4, 0, 0)
				toggleHolder.BackgroundTransparency = 1
				toggleHolder.Text = ""
				local trackToggle = Instance.new("Frame", toggleHolder)
				trackToggle.Size = UDim2.fromOffset(36, 18)
				trackToggle.Position = UDim2.new(1, -36, 0.5, 0)
				trackToggle.AnchorPoint = Vector2.new(1, 0.5)
				trackToggle.BackgroundColor3 = THEME.panelHighlight
				Instance.new("UICorner", trackToggle).CornerRadius = UDim.new(1, 0)
				local thumb = Instance.new("Frame", trackToggle)
				thumb.Size = UDim2.fromOffset(14, 14)
				thumb.AnchorPoint = Vector2.new(0.5, 0.5)
				thumb.BackgroundColor3 = THEME.textActive
				Instance.new("UICorner", thumb).CornerRadius = UDim.new(1, 0)
                local function UpdateToggleVisuals(isOn, isInstant)
                    local tweenInfo = isInstant and TweenInfo.new(0) or TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local targetTrackColor = isOn and THEME.accent or THEME.panelHighlight
                    local targetThumbPos = isOn and UDim2.new(1, -9, 0.5, 0) or UDim2.new(0, 9, 0.5, 0)
                    TweenService:Create(trackToggle, tweenInfo, { BackgroundColor3 = targetTrackColor }):Play()
                    TweenService:Create(thumb, tweenInfo, { Position = targetThumbPos }):Play()
                end
                Library:_OnAccentChanged(function()
                    UpdateToggleVisuals(toggledState, true)
                end)
				toggleHolder.Activated:Connect(function()
					toggledState = not toggledState
					UpdateToggleVisuals(toggledState, false)
					if opts.OnToggleChange then
						opts.OnToggleChange(toggledState)
					end
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(currentValue, toggledState)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, { value = currentValue, toggled = toggledState })
					end
				end)
				UpdateToggleVisuals(toggledState, true)

				local stObject = {}
				stObject.Object = { Slider = sliderHolder, Toggle = toggleHolder }
				stObject.GetSliderValue = function()
					return currentValue
				end
				stObject.SetSliderValue = function(v)
					v = math.clamp(v, sliderMin, sliderMax)
					local percentage = (v - sliderMin) / (sliderMax - sliderMin)
					targetPercentage = percentage
					currentPercentage = percentage -- ÐœÐ³Ð½Ð¾Ð²ÐµÐ½Ð½Ð¾Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ
					UpdateSliderVisuals(percentage) -- [[ Ð˜Ð—ÐœÐ•ÐÐ•ÐÐž ]] -- Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ‹Ð·Ð¾Ð²ÐµÑ‚ Ð²ÑÐµ Callbacks
				end
				stObject.GetToggleState = function()
					return toggledState
				end
				stObject.SetToggleState = function(v)
					local newState = v and true or false
					if toggledState == newState then return end

					toggledState = newState
					UpdateToggleVisuals(toggledState, false) -- ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ UI

					-- [[ Ð”ÐžÐ‘ÐÐ’Ð›Ð•ÐÐž ]] -- Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð²ÑÐµ Callbacks Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ
					if opts.OnToggleChange then
						opts.OnToggleChange(toggledState)
					end
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(currentValue, toggledState)
					end
					if opts.SaveKey then
						Library:_SaveSetting(opts.SaveKey, { value = currentValue, toggled = toggledState })
					end
				end
				stObject.Call = function(val, toggle)
					local value = val or currentValue
					local tog = (toggle ~= nil) and toggle or toggledState
					if opts.Callback and not Library._suppressCallbacks then opts.Callback(value, tog)
					end
				end

				if opts.SaveKey then
					Library._widgetRegistry[opts.SaveKey] = stObject
				end
				return stObject
			end
			return Section
		end
		return Page
	end
	task.wait()
	local initialFadeInTween = Library:_TweenGroupTransparency(rootFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), 0)
	initialFadeInTween.Completed:Connect(function()
		isAnimating = false
		isVisible = true
	end)
	initialFadeInTween:Play()
	function Window:SetPageOrder(order)
		applyPageOrder(order)
	end
	function Window:GetPageOrder()
		return getPageOrder()
	end
	
	return Window
end

--[[ Library Save Methods ]]

function Library:SetSaveKey(saveKey, value)
	if not self._widgetRegistry then return end
	local widget = self._widgetRegistry[saveKey]
	if not widget then return end

	if typeof(value) == "table" then
		if widget.SetSliderValue and widget.SetToggleState then -- SliderToggle
			if value.value ~= nil then widget.SetSliderValue(value.value) end
			if value.toggled ~= nil then widget.SetToggleState(value.toggled) end
			return
		elseif widget.GetSelection and widget.GetValue then -- SliderButtonDropdown
			 if value.item ~= nil then widget.SetSelection(value.item) end
			 if value.value ~= nil then widget.SetValue(value.value) print(value.value) end
			 return
		elseif widget.GetSelections then -- MultiSelectDropdown
            widget.SetSelection(value)
			return
		end
	end
	
	if widget.SetState then
		widget.SetState(value)
	elseif widget.SetNumber then
		widget.SetNumber(value)
	elseif widget.SetSelection then
		widget.SetSelection(value)
	elseif widget.SetText then
		widget.SetText(value)
	elseif widget.SetKey then
		widget.SetKey(value)
	end
end

function Library:ApplyAllSaveKeys()
	if not self._widgetRegistry then return end
	for key, _ in pairs(self._widgetRegistry) do
		self:SetSaveKey(key)
	end
end

function Library:GetSettings(saveKey)
	if not self._widgetRegistry or not saveKey then return nil end
	local widget = self._widgetRegistry[saveKey]
	if not widget then return nil end

	-- Compound widgets
	if widget.GetSelectedItems then
		return widget:GetSelectedItems()
	elseif widget.GetSliderValue and widget.GetToggleState then
		return { value = widget:GetSliderValue(), toggled = widget:GetToggleState() }
	elseif widget.GetSelection and widget.GetValue then
		return { item = widget:GetSelection(), value = widget:GetValue() }
elseif widget.GetSelections then
    return widget:GetSelections()
-- Simple widgets
elseif widget.GetState then
    return widget:GetState()
elseif widget.GetValue then
    return widget:GetValue()
elseif widget.GetSelection then
    return widget:GetSelection()
elseif widget.GetKey then
    return keycodeToString(widget:GetKey())
elseif widget.GetText then
    return widget:GetText()
end

	return nil
end

function Library:LoadConfig(savefile)
	if not savefile then
		warn("LoadConfig: Ð¤Ð°Ð¹Ð» ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½.")
		return
	end

	if typeof(isfile) ~= "function" or typeof(readfile) ~= "function" or not isfile(savefile) then
		return
	end

	local HttpService = game:GetService("HttpService")

	local readSuccess, fileContent = pcall(readfile, savefile)
	if not readSuccess or not fileContent or fileContent == "" then
		warn("LoadConfig: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ñ„Ð°Ð¹Ð»Ð°: " .. savefile)
		return
	end

	local decodeSuccess, configData = pcall(HttpService.JSONDecode, HttpService, fileContent)
	if not decodeSuccess or typeof(configData) ~= "table" then
		warn("LoadConfig: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð´ÐµÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ JSON Ð¸Ð· Ñ„Ð°Ð¹Ð»Ð°: " .. savefile)
		return
	end

	local wasAutoSaveEnabled = self.autoSaveEnabled
	self.autoSaveEnabled = false
	local prevSuppress = self._suppressCallbacks
	self._suppressCallbacks = true

	for key, value in pairs(configData) do
		if self._widgetRegistry[key] then
			self:SetSaveKey(key, value)
		end
	end

	self._suppressCallbacks = prevSuppress
	self.autoSaveEnabled = wasAutoSaveEnabled
end

-- Attach optional modules if present (Utils, KeySystem, Notifications, HelpBubbles)
pcall(function()
    if script and script.Parent then
        local function requireIfExists(name)
            local child = script.Parent:FindFirstChild(name)
            if child then
                local ok, mod = pcall(require, child)
                if ok then return mod end
            end
            return nil
        end

        local utils = requireIfExists("Utils")
        if utils then
            Library.Utils = utils
        end

        local attach = function(name)
            local mod = requireIfExists(name)
            if typeof(mod) == "function" then
                pcall(mod, Library)
            end
        end

        attach("KeySystem")
        attach("Notifications")
        attach("HelpBubbles")
    end
end)

return Library




